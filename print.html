<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to the <strong>Motoko Regex Engine Documentation</strong>, your go-to guide for leveraging the power of regular expressions in the Motoko programming language. This engine provides robust tools for pattern matching, searching, and text processing.</p>
<p>Inspired by other established regex libraries, this regex engine adapts their capabilities to meet the needs of Motoko.</p>
<hr />
<h2 id="installation-and-import"><a class="header" href="#installation-and-import">Installation and Import</a></h2>
<p>Install the Motoko Regex Engine using:</p>
<pre><code class="language-bash">mops add regex
</code></pre>
<p>Import it into your project with:</p>
<pre><code class="language-motoko">import Regex "mo:regex";
</code></pre>
<hr />
<h2 id="what-is-a-regular-expression"><a class="header" href="#what-is-a-regular-expression">What is a Regular Expression?</a></h2>
<p>A <strong>regular expression</strong> (regex) is a sequence of characters defining a search pattern. Regex is widely used in text processing for tasks such as:</p>
<ul>
<li>Searching for text patterns (e.g., keywords in a document).</li>
<li>Validating formats (e.g., email addresses or phone numbers).</li>
<li>Extracting data from structured text (e.g., logs or CSV files).</li>
</ul>
<p>For example, the regex <code>^\d{3}-\d{2}-\d{4}$</code> matches a string formatted as a Social Security Number, such as <code>123-45-6789</code>.</p>
<hr />
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<h3 id="pattern-support"><a class="header" href="#pattern-support">Pattern Support</a></h3>
<ul>
<li><strong>Anchors</strong>: <code>^</code> (start of string), <code>$</code> (end of string).</li>
<li><strong>Character classes</strong>: <code>[a-z]</code>, <code>[^0-9]</code>.</li>
<li><strong>Quantifiers</strong>: <code>*</code>, <code>+</code>, <code>?</code>, <code>{m,n}</code>.</li>
<li><strong>Groups</strong>: <code>()</code>, <code>(?:)</code>.</li>
<li><strong>Alternation</strong>: <code>|</code> (logical OR).</li>
<li><strong>Escapes</strong>: <code>\d</code>, <code>\w</code>, <code>\s</code>, etc.</li>
</ul>
<h3 id="flags"><a class="header" href="#flags">Flags</a></h3>
<p>Flags are optional boolean values that modify the behavior of regex matching. They are set during instantiation and cannot be changed afterward. The engine currently supports:</p>
<ul>
<li><strong><code>caseSensitive</code></strong>: Case-sensitive matching (default is true).</li>
<li><strong><code>multiline</code></strong>: Enables multiline matching.</li>
</ul>
<p>Example with null flags (default behavior):</p>
<pre><code class="language-motoko">let regex = Regex.Regex("\d{3}-\d{2}-\d{4}", null);
</code></pre>
<h3 id="api-functions"><a class="header" href="#api-functions">API Functions</a></h3>
<ul>
<li><strong><code>match</code></strong>: Check for a full match of the pattern in the input text.</li>
<li><strong><code>search</code></strong>: Locate the first occurrence of the pattern in the input.</li>
<li><strong><code>findAll</code></strong>: Retrieve all matches for the pattern.</li>
<li><strong><code>findIter</code></strong>: Iterate over matches.</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="syntax"><a class="header" href="#syntax">Syntax</a></h1>
<ul>
<li><a href="syntax.html#syntax">Syntax</a>
<ul>
<li><a href="syntax.html#supported-syntax">Supported Syntax</a></li>
<li><a href="syntax.html#quantifiers">Quantifiers</a>
<ul>
<li><a href="syntax.html#supported-quantifiers">Supported Quantifiers</a></li>
<li><a href="syntax.html#quantifier-modes">Quantifier Modes</a></li>
<li><a href="syntax.html#invalid-quantifiers">Invalid Quantifiers</a></li>
</ul>
</li>
<li><a href="syntax.html#metacharacters">Metacharacters</a></li>
<li><a href="syntax.html#character-classes">Character Classes</a>
<ul>
<li><a href="syntax.html#nested-quantifiers">Nested Quantifiers</a></li>
</ul>
</li>
<li><a href="syntax.html#anchors">Anchors</a></li>
<li><a href="syntax.html#groups-and-group-modifiers">Groups and Group Modifiers</a>
<ul>
<li><a href="syntax.html#supported-group-modifiers">Supported Group Modifiers</a></li>
</ul>
</li>
<li><a href="syntax.html#escaped-characters">Escaped Characters</a></li>
<li><a href="syntax.html#prohibited-patterns">Prohibited Patterns</a></li>
<li><a href="syntax.html#error-handling">Error Handling</a>
<ul>
<li><a href="syntax.html#error-types">Error Types</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<h2 id="supported-syntax"><a class="header" href="#supported-syntax">Supported Syntax</a></h2>
<p>Motoko regex supports a variety of syntax features for defining patterns. These include:</p>
<ul>
<li>Character matching (<code>a</code>, <code>b</code>, <code>c</code>, etc.)</li>
<li>Alternation (<code>|</code>)</li>
<li>Grouping (<code>()</code>)</li>
<li>Character classes (<code>[]</code> with support for ranges like <code>[a-z]</code>)</li>
<li>Quantifiers (<code>*</code>, <code>+</code>, <code>?</code>, <code>{n}</code>, <code>{n,m}</code>)</li>
<li>Anchors (<code>^</code>, <code>$</code>)</li>
</ul>
<hr />
<h2 id="quantifiers"><a class="header" href="#quantifiers">Quantifiers</a></h2>
<p>Quantifiers specify how many times a preceding element must occur for a match.</p>
<h3 id="supported-quantifiers"><a class="header" href="#supported-quantifiers">Supported Quantifiers</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Quantifier</th><th>Meaning</th><th>Example</th></tr></thead><tbody>
<tr><td><code>*</code></td><td>Match 0 or more times</td><td><code>a*</code> matches "", "a", "aaa"</td></tr>
<tr><td><code>+</code></td><td>Match 1 or more times</td><td><code>a+</code> matches "a", "aaa"</td></tr>
<tr><td><code>?</code></td><td>Match 0 or 1 time</td><td><code>a?</code> matches "", "a"</td></tr>
<tr><td><code>{n}</code></td><td>Match exactly <code>n</code> times</td><td><code>a{2}</code> matches "aa"</td></tr>
<tr><td><code>{n,}</code></td><td>Match at least <code>n</code> times</td><td><code>a{2,}</code> matches "aa", "aaa"</td></tr>
<tr><td><code>{n,m}</code></td><td>Match between <code>n</code> and <code>m</code> times</td><td><code>a{2,4}</code> matches "aa", "aaa", "aaaa"</td></tr>
</tbody></table>
</div>
<h3 id="quantifier-modes"><a class="header" href="#quantifier-modes">Quantifier Modes</a></h3>
<p>Quantifiers can operate in different modes:</p>
<ul>
<li><strong>Greedy:</strong> Matches as many occurrences as possible.</li>
<li><strong>Lazy (<code>?</code> after quantifier):</strong> Matches as few as possible. E.g., <code>a+?</code> matches fewer occurrences of "a".</li>
</ul>
<h3 id="invalid-quantifiers"><a class="header" href="#invalid-quantifiers">Invalid Quantifiers</a></h3>
<p>Certain quantifier patterns are not allowed:</p>
<ul>
<li>Redundant modifiers, such as <code>a{2}+</code> or <code>a{2}*</code>.</li>
<li>Empty quantifiers, e.g., <code>{}</code> or <code>{,}</code>.</li>
<li>Multiple commas in ranges, e.g., <code>{2,,4}</code>.</li>
</ul>
<hr />
<h2 id="metacharacters"><a class="header" href="#metacharacters">Metacharacters</a></h2>
<p>Metacharacters represent special patterns or symbols.</p>
<div class="table-wrapper"><table><thead><tr><th>Metacharacter</th><th>Meaning</th><th>Example</th></tr></thead><tbody>
<tr><td><code>.</code></td><td>Match any character except <code>\n</code></td><td><code>a.b</code> matches "acb"</td></tr>
<tr><td><code>\w</code></td><td>Match word characters (alphanumeric + <code>_</code>)</td><td><code>\w+</code> matches "abc123"</td></tr>
<tr><td><code>\W</code></td><td>Match non-word characters</td><td><code>\W</code> matches "@"</td></tr>
<tr><td><code>\d</code></td><td>Match digits (<code>0-9</code>)</td><td><code>\d+</code> matches "123"</td></tr>
<tr><td><code>\D</code></td><td>Match non-digits</td><td><code>\D</code> matches "a"</td></tr>
<tr><td><code>\s</code></td><td>Match whitespace</td><td><code>\s+</code> matches "   "</td></tr>
<tr><td><code>\S</code></td><td>Match non-whitespace</td><td><code>\S</code> matches "a"</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="character-classes"><a class="header" href="#character-classes">Character Classes</a></h2>
<p>Character classes allow matching sets of characters.</p>
<ul>
<li><code>[abc]</code>: Matches any character <code>a</code>, <code>b</code>, or <code>c</code>.</li>
<li><code>[^abc]</code>: Matches any character except <code>a</code>, <code>b</code>, or <code>c</code>.</li>
<li><code>[a-z]</code>: Matches any character in the range <code>a</code> to <code>z</code>.</li>
</ul>
<h3 id="nested-quantifiers"><a class="header" href="#nested-quantifiers">Nested Quantifiers</a></h3>
<p>Quantifiers inside character classes must be explicitly defined. Nested or redundant quantifiers, like <code>[a-z]{2}+</code>, are not allowed.</p>
<hr />
<h2 id="anchors"><a class="header" href="#anchors">Anchors</a></h2>
<p>Anchors specify positions in the text.</p>
<div class="table-wrapper"><table><thead><tr><th>Anchor</th><th>Meaning</th><th>Example</th></tr></thead><tbody>
<tr><td><code>^</code></td><td>Start of the string</td><td><code>^abc</code> matches "abc" at the beginning</td></tr>
<tr><td><code>$</code></td><td>End of the string</td><td><code>abc$</code> matches "abc" at the end</td></tr>
<tr><td><code>\b</code></td><td>Word boundary</td><td><code>\bword\b</code> matches "word"</td></tr>
<tr><td><code>\B</code></td><td>Non-word boundary</td><td><code>\Bword</code> matches "word" not at a boundary</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="groups-and-group-modifiers"><a class="header" href="#groups-and-group-modifiers">Groups and Group Modifiers</a></h2>
<p>Groups are enclosed in parentheses <code>()</code> and can be modified for specific behaviors.</p>
<h3 id="supported-group-modifiers"><a class="header" href="#supported-group-modifiers">Supported Group Modifiers</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Modifier</th><th>Syntax</th><th>Meaning</th></tr></thead><tbody>
<tr><td>Non-capturing</td><td><code>(?:...)</code></td><td>Groups without capturing</td></tr>
<tr><td>Positive Lookahead</td><td><code>(?=...)</code></td><td>Asserts that what follows matches</td></tr>
<tr><td>Negative Lookahead</td><td><code>(?!...)</code></td><td>Asserts that what follows does not match</td></tr>
<tr><td>Positive Lookbehind</td><td><code>(?&lt;=...)</code></td><td>Asserts that what precedes matches</td></tr>
<tr><td>Negative Lookbehind</td><td><code>(?&lt;!...)</code></td><td>Asserts that what precedes does not match</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="escaped-characters"><a class="header" href="#escaped-characters">Escaped Characters</a></h2>
<p>Escape sequences represent special characters.</p>
<div class="table-wrapper"><table><thead><tr><th>Escape Sequence</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>\\</code></td><td>Literal backslash</td></tr>
<tr><td><code>\n</code></td><td>Newline</td></tr>
<tr><td><code>\t</code></td><td>Tab</td></tr>
<tr><td><code>\w</code>, <code>\W</code></td><td>Word/Non-word characters</td></tr>
<tr><td><code>\d</code>, <code>\D</code></td><td>Digit/Non-digit</td></tr>
<tr><td><code>\s</code>, <code>\S</code></td><td>Whitespace/Non-whitespace</td></tr>
</tbody></table>
</div>
<p>Invalid escape sequences throw an error.</p>
<hr />
<h2 id="prohibited-patterns"><a class="header" href="#prohibited-patterns">Prohibited Patterns</a></h2>
<ul>
<li>Invalid group modifiers: e.g., <code>(?)</code>.</li>
<li>Empty groups: <code>()</code> is not allowed.</li>
<li>Empty character classes: <code>[]</code> results in an error.</li>
<li>Redundant or conflicting quantifiers: <code>a{2}+</code>.</li>
</ul>
<hr />
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<p>The Motoko regex engine provides detailed error feedback to help developers identify and fix issues in their regular expressions. Below is a list of all possible errors, their meanings, and typical scenarios where they might occur.</p>
<h3 id="error-types"><a class="header" href="#error-types">Error Types</a></h3>
<div class="table-wrapper"><table><thead><tr><th><strong>Error</strong></th><th><strong>Description</strong></th><th><strong>Cause</strong></th></tr></thead><tbody>
<tr><td><strong><code>#UnexpectedCharacter</code></strong></td><td>An invalid character was encountered during parsing.</td><td>Using a character that is not allowed in regex syntax, such as unescaped special characters.</td></tr>
<tr><td><strong><code>#UnexpectedEndOfInput</code></strong></td><td>The regex input ended unexpectedly, leaving constructs incomplete.</td><td>Omitting closing brackets, parentheses, or quantifier ranges.</td></tr>
<tr><td><strong><code>#GenericError</code></strong></td><td>A generic error message providing additional context.</td><td>Various syntax or logic errors not covered by specific error types.</td></tr>
<tr><td><strong><code>#InvalidQuantifierRange</code></strong></td><td>A malformed or invalid quantifier range was used.</td><td>Using invalid quantifier syntax, e.g., <code>{,}</code>, <code>{,3}</code>, <code>{a,b}</code>.</td></tr>
<tr><td><strong><code>#InvalidEscapeSequence</code></strong></td><td>An invalid escape sequence was encountered.</td><td>Using unrecognized escape sequences like <code>\q</code> or <code>\x</code> without proper syntax.</td></tr>
<tr><td><strong><code>#UnmatchedParenthesis</code></strong></td><td>A closing parenthesis <code>)</code> does not match any preceding opening parenthesis <code>(</code>.</td><td>Missing or extra closing parentheses in the regex pattern.</td></tr>
<tr><td><strong><code>#MismatchedParenthesis</code></strong></td><td>Parentheses do not form a valid pairing.</td><td>Nested parentheses are incorrectly matched or unbalanced, e.g., <code>((a)b])</code>.</td></tr>
<tr><td><strong><code>#UnexpectedToken</code></strong></td><td>An unexpected token was encountered during parsing.</td><td>Using misplaced or unrecognized tokens in the regex pattern.</td></tr>
<tr><td><strong><code>#UnclosedGroup</code></strong></td><td>A group construct is not properly closed with a closing parenthesis <code>)</code>.</td><td>Missing a closing parenthesis in a group definition.</td></tr>
<tr><td><strong><code>#InvalidQuantifier</code></strong></td><td>A quantifier is malformed or applied in an invalid context.</td><td>Using redundant or conflicting quantifiers, e.g., <code>a{2}+</code>.</td></tr>
<tr><td><strong><code>#EmptyExpression</code></strong></td><td>The regex input is empty or contains no valid expressions.</td><td>Providing an empty string or expression with no meaningful content.</td></tr>
<tr><td><strong><code>#NotCompiled</code></strong></td><td>The regex has not been compiled before attempting to use it.</td><td>There was an error during compilation of the reject object, this may be due to any of the previous errors. That error will be specified in the <code>#NotCompiled</code> variant.</td></tr>
</tbody></table>
</div>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="flags-1"><a class="header" href="#flags-1">Flags</a></h1>
<p>Flags in Motoko regex provide flexibility by modifying the behavior of the regex matching process. This section covers the available flags, their purpose, and how to use them effectively.</p>
<hr />
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Flags are optional parameters that can alter how the regex engine interprets and processes a pattern. They enable features such as case-insensitive matching and handling multiline inputs.</p>
<hr />
<h2 id="available-flags"><a class="header" href="#available-flags">Available Flags</a></h2>
<h3 id="1-case_sensitive"><a class="header" href="#1-case_sensitive"><strong>1. CASE_SENSITIVE</strong></a></h3>
<ul>
<li>
<p><strong>Type:</strong> <code>Bool</code></p>
</li>
<li>
<p><strong>Default:</strong> <code>true</code></p>
</li>
<li>
<p><strong>Description:</strong> Determines whether the regex should consider case when matching characters.</p>
</li>
<li>
<p><strong>Behavior:</strong></p>
<ul>
<li>When <code>caseSensitive = true</code>: Matches are case-sensitive (default behavior).</li>
<li>When <code>caseSensitive = false</code>: Matches are case-insensitive, treating uppercase and lowercase letters as equivalent.</li>
</ul>
</li>
<li>
<p><strong>Example:</strong></p>
<pre><code class="language-motoko">let regex = Regex.Regex("abc", ?{caseSensitive = false});
assert(regex.search("ABC") == #FullMatch);
</code></pre>
</li>
</ul>
<h3 id="2-multiline"><a class="header" href="#2-multiline"><strong>2. MULTILINE</strong></a></h3>
<ul>
<li>
<p><strong>Type:</strong> <code>Bool</code></p>
</li>
<li>
<p><strong>Default:</strong> <code>false</code></p>
</li>
<li>
<p><strong>Description:</strong> Alters the behavior of anchors (<code>^</code> and <code>$</code>) to match at line boundaries rather than the start or end of the entire string.</p>
</li>
<li>
<p><strong>Behavior:</strong></p>
<ul>
<li>When <code>multiline = true</code>:
<ul>
<li><code>^</code> matches the start of any line.</li>
<li><code>$</code> matches the end of any line.</li>
</ul>
</li>
<li>When <code>multiline = false</code> (default behavior):
<ul>
<li><code>^</code> matches the beginning of the entire input.</li>
<li><code>$</code> matches the end of the entire input.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Example:</strong></p>
<pre><code class="language-motoko">let regex = Regex.Regex("^abc$", ?{multiline = true});
assert(regex.search("abc\ndef\nabc") == #FullMatch);
</code></pre>
</li>
</ul>
<hr />
<h2 id="combining-flags"><a class="header" href="#combining-flags">Combining Flags</a></h2>
<p>You can combine flags to fine-tune the regex engine's behavior. For example:</p>
<pre><code class="language-motoko">let regex = Regex.Regex("abc", ?{caseSensitive = false; multiline = true});
assert(regex.search("ABC\ndef\nabc") == #FullMatch);
</code></pre>
<p>In this example:</p>
<ul>
<li>The pattern <code>abc</code> is matched regardless of case.</li>
<li>The engine processes each line independently due to <code>multiline = true</code>.</li>
</ul>
<hr />
<h2 id="default-behavior-without-flags"><a class="header" href="#default-behavior-without-flags">Default Behavior Without Flags</a></h2>
<p>If no flags are specified, the engine uses the following defaults:</p>
<ul>
<li><code>caseSensitive = true</code></li>
<li><code>multiline = false</code></li>
</ul>
<p>This means:</p>
<ul>
<li>Matching is case-sensitive.</li>
<li>Anchors (<code>^</code> and <code>$</code>) match only at the start and end of the entire input.</li>
</ul>
<hr />
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<ul>
<li>Use <code>caseSensitive = false</code> for patterns that need to ignore case differences, such as matching user inputs in a case-insensitive manner.</li>
<li>Use <code>multiline = true</code> when processing multi-line text, such as logs or formatted documents, where each line might have independent matching requirements.</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>This section provides an overview of the (current) functions available in this library. Use the links below to navigate to detailed documentation for each function.</p>
<ul>
<li><a href="functions/search.html">search()</a></li>
<li><a href="functions/match.html">match()</a></li>
<li><a href="functions/findall.html">findAll()</a></li>
<li><a href="functions/finditer.html">findIter()</a></li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview-1"><a class="header" href="#overview-1">Overview</a></h1>
<p>The <code>search()</code> function scans an input string for the first occurrence of the regex pattern. Unlike <code>match()</code>, which requires the pattern to span the entire input, <code>search()</code> identifies the first substring that satisfies the pattern.</p>
<h2 id="signature"><a class="header" href="#signature">Signature</a></h2>
<pre><code class="language-motoko">public func search(text: Text): Result.Result&lt;Match, RegexError&gt;
</code></pre>
<h2 id="parameters"><a class="header" href="#parameters">Parameters</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>text</td><td>Text</td><td>The input string to search for the first match</td></tr>
</tbody></table>
</div>
<h2 id="return-value"><a class="header" href="#return-value">Return Value</a></h2>
<p><strong>Type</strong>: <code>Result.Result&lt;Match, RegexError&gt;</code></p>
<h3 id="success-case"><a class="header" href="#success-case">Success Case</a></h3>
<p>Returns a <code>Match</code> object containing:</p>
<ul>
<li>The matched substring (<code>value</code>)</li>
<li>The position of the match within the input string</li>
<li>Captured groups (if any)</li>
</ul>
<h3 id="no-match-case"><a class="header" href="#no-match-case">No Match Case</a></h3>
<p>Returns a <code>Match</code> object with:</p>
<ul>
<li><code>status = #NoMatch</code></li>
<li>Empty <code>value</code></li>
</ul>
<h3 id="error-case"><a class="header" href="#error-case">Error Case</a></h3>
<p>Returns <code>RegexError</code> (<code>#NotCompiled</code>) only if the pattern failed to compile during instantiation</p>
<h2 id="behavior"><a class="header" href="#behavior">Behavior</a></h2>
<h3 id="input-validation"><a class="header" href="#input-validation">Input Validation</a></h3>
<ul>
<li>If the regex instantiation failed (due to an invalid pattern), returns <code>RegexError</code> (<code>#NotCompiled</code>)</li>
</ul>
<h3 id="search-process"><a class="header" href="#search-process">Search Process</a></h3>
<ol>
<li>Scans the input string character by character</li>
<li>Identifies if a potential match could begin at the current position</li>
<li>Delegates to <code>match()</code> for full matching starting from that position</li>
</ol>
<h3 id="result-construction"><a class="header" href="#result-construction">Result Construction</a></h3>
<ul>
<li>On finding a match:
<ul>
<li>Returns a <code>Match</code> object with details of the match</li>
</ul>
</li>
<li>If no match is found after scanning the string:
<ul>
<li>Returns a <code>Match</code> object with <code>status = #NoMatch</code></li>
</ul>
</li>
</ul>
<h2 id="example-usage"><a class="header" href="#example-usage">Example Usage</a></h2>
<h3 id="1-successful-match"><a class="header" href="#1-successful-match">1. Successful Match</a></h3>
<p><strong>Pattern</strong>: <code>"a+"</code> <strong>Input</strong>: <code>"xxaaayy"</code></p>
<pre><code class="language-motoko">let pattern = Regex.Regex("a+", null);
let result = pattern.search("xxaaayy");
switch (result) {
    case (#ok(match)) Debug.print("First match: " # match.value);  // Output: "aaa"
    case (#err(error)) Debug.print("Error: " # debug_show(error));
};
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code>First match: aaa
</code></pre>
<h3 id="2-no-match-found"><a class="header" href="#2-no-match-found">2. No Match Found</a></h3>
<p><strong>Pattern</strong>: <code>"z+"</code> <strong>Input</strong>: <code>"xxaaaayy"</code></p>
<pre><code class="language-motoko">let pattern = Regex.Regex("z+", null);
let result = pattern.search("xxaaaayy");
switch (result) {
    case (#ok(match)) {
        switch (match.status) {
            case (#NoMatch) Debug.print("No match found.");
            case (#FullMatch) Debug.print("First match: " # match.value);
        };
    };
    case (#err(error)) Debug.print("Error: " # debug_show(error));
};
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code>No match found.
</code></pre>
<h3 id="3-invalid-pattern"><a class="header" href="#3-invalid-pattern">3. Invalid Pattern</a></h3>
<p><strong>Scenario</strong>: Creating a regex with an invalid pattern</p>
<pre><code class="language-motoko">let pattern = Regex.Regex("[a-");
let result = pattern.search("xxaaaayy");
switch (result) {
    case (#ok(match)) Debug.print("First match: " # match.value);
    case (#err(error)) Debug.print("Error: " # debug_show(error)); // Output: #NotCompiled
};
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code>Error: #NotCompiled
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview-2"><a class="header" href="#overview-2"><strong>Overview</strong></a></h1>
<p>The <code>match()</code> function is a core API for performing regex-based matching. It takes an input string and matches it against a precompiled regex represented as an NFA. The function handles matching mechanics, including state transitions, greedy and lazy quantifiers, and group captures.</p>
<hr />
<h2 id="signature-1"><a class="header" href="#signature-1"><strong>Signature</strong></a></h2>
<pre><code class="language-motoko">public func match(text: Text): Result.Result&lt;Match, RegexError&gt;
</code></pre>
<hr />
<h3 id="parameters-1"><a class="header" href="#parameters-1"><strong>Parameters</strong></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>text</code></td><td><code>Text</code></td><td>The input string to be matched against the compiled regex.</td></tr>
</tbody></table>
</div>
<hr />
<h3 id="return-value-1"><a class="header" href="#return-value-1"><strong>Return Value</strong></a></h3>
<p><code>Result.Result&lt;Match, RegexError&gt;</code>:</p>
<ul>
<li><strong>On Success</strong> (<code>Match</code>):
<ul>
<li>Contains details of the match, such as the matched substring, captured groups, and spans.</li>
</ul>
</li>
<li><strong>On Failure</strong> (<code>RegexError</code>):
<ul>
<li>Indicates why the matching process failed (e.g., regex not compiled).</li>
</ul>
</li>
</ul>
<hr />
<h3 id="behavior-1"><a class="header" href="#behavior-1"><strong>Behavior</strong></a></h3>
<ol>
<li>
<p><strong>Input Validation</strong>:</p>
<ul>
<li>Checks if the regex has been compiled.</li>
<li>Returns <code>#NotCompiled</code> error if the regex is unavailable.</li>
</ul>
</li>
<li>
<p><strong>Matching Process</strong>:</p>
<ul>
<li>Delegates the actual matching logic to the <code>matcher.match</code> function.</li>
<li>Traverses the NFA based on input characters.</li>
<li>Respects greedy and lazy quantifier modes.</li>
<li>Handles capture groups and anchors (e.g., <code>^</code>, <code>$</code>).</li>
</ul>
</li>
<li>
<p><strong>Result Construction</strong>:</p>
<ul>
<li>Builds a <code>Match</code> object for successful matches.</li>
<li>Returns <code>RegexError</code> for failures.</li>
</ul>
</li>
</ol>
<hr />
<h3 id="example-usage-1"><a class="header" href="#example-usage-1"><strong>Example Usage</strong></a></h3>
<h4 id="1-successful-match-1"><a class="header" href="#1-successful-match-1"><strong>1. Successful Match</strong></a></h4>
<pre><code class="language-motoko">let pattern = Regex.Regex("h.*o",null); 
let result = pattern.match("hello");

switch (result) {
  case (#ok(match)) {
    Debug.print("Matched value: " # match.value);
  };
  case (#err(error)) {
    Debug.print("Error: " # debug_show(error));
  };
}
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code>Matched value: hello
</code></pre>
<hr />
<h4 id="2-no-match"><a class="header" href="#2-no-match"><strong>2. No Match</strong></a></h4>
<pre><code class="language-motoko">let pattern = Regex.Regex("z+",null);
let result = pattern.match("hello");

switch (result) {
  case (#ok(match)) {
    Debug.print("Matched value: " # match.value);
  };
  case (#err(error)) {
    Debug.print("Error: " # debug_show(error));
  };
}
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code>#ok: status = #NoMatch
</code></pre>
<hr />
<h4 id="input-validation-1"><a class="header" href="#input-validation-1"><strong>Input Validation</strong></a></h4>
<ul>
<li>
<p>Before matching, the function ensures the regex is compiled.</p>
</li>
<li>
<p>If <code>nfa</code> is <code>null</code>, the function returns:</p>
<pre><code class="language-motoko">#err(#NotCompiled)
</code></pre>
</li>
</ul>
<hr />
<h4 id="delegation-to-matchermatch"><a class="header" href="#delegation-to-matchermatch"><strong>Delegation to <code>matcher.match</code></strong></a></h4>
<ul>
<li>The compiled NFA, input <code>text</code>, and optional <code>flags</code> are passed to <code>matcher.match</code>.</li>
<li><code>matcher.match</code> performs:
<ul>
<li><strong>State Transitions</strong>:
<ul>
<li>Moves between states in the NFA based on input characters.</li>
</ul>
</li>
<li><strong>Greedy and Lazy Quantifiers</strong>:
<ul>
<li>Greedy quantifiers consume as much input as possible.</li>
<li>Lazy quantifiers stop at the first valid match.</li>
</ul>
</li>
<li><strong>Capture Groups</strong>:
<ul>
<li>Tracks and extracts group matches.</li>
</ul>
</li>
<li><strong>Anchors</strong>:
<ul>
<li>Ensures patterns anchored to the start (<code>^</code>) or end (<code>$</code>) are respected.</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview-3"><a class="header" href="#overview-3">Overview</a></h1>
<p>The <code>findAll()</code> method returns an array of all non-overlapping matches of the regex pattern in the input text. Unlike <code>findIter()</code>, this method collects all matches at once into an array.</p>
<h2 id="signature-2"><a class="header" href="#signature-2">Signature</a></h2>
<pre><code class="language-motoko">public func findAll(text: Text): Result.Result&lt;[Match], RegexError&gt;
</code></pre>
<h2 id="parameters-2"><a class="header" href="#parameters-2">Parameters</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>text</td><td>Text</td><td>The input string to search for matches</td></tr>
</tbody></table>
</div>
<h2 id="return-value-2"><a class="header" href="#return-value-2">Return Value</a></h2>
<p><strong>Type</strong>: <code>Result.Result&lt;[Match], RegexError&gt;</code></p>
<h3 id="success-case-1"><a class="header" href="#success-case-1">Success Case</a></h3>
<p>Returns an array of <code>Match</code> objects, where each contains:</p>
<ul>
<li>The matched substring (<code>value</code>)</li>
<li>The position of the match within the input string</li>
<li>Any captured groups</li>
<li>Match status (<code>#FullMatch</code>)</li>
</ul>
<h3 id="error-case-1"><a class="header" href="#error-case-1">Error Case</a></h3>
<p>Returns <code>RegexError</code> (<code>#NotCompiled</code>) if the pattern failed to compile during instantiation</p>
<h3 id="match-collection-process"><a class="header" href="#match-collection-process">Match Collection Process</a></h3>
<ol>
<li>Starts from the beginning of the input string</li>
<li>Collects all non-overlapping matches into an array</li>
<li>Preserves the order of matches as they appear in the text</li>
<li>Returns an empty array if no matches are found</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview-4"><a class="header" href="#overview-4">Overview</a></h1>
<p>The <code>findIter()</code> method returns an iterator that yields all non-overlapping matches of the regex pattern in the input text. This method is memory-efficient as it generates matches lazily instead of collecting them all at once like <code>findAll()</code>.</p>
<h2 id="signature-3"><a class="header" href="#signature-3">Signature</a></h2>
<pre><code class="language-motoko">public func findIter(text: Text): Result.Result&lt;Iter.Iter&lt;Match&gt;, RegexError&gt;
</code></pre>
<h2 id="parameters-3"><a class="header" href="#parameters-3">Parameters</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>text</td><td>Text</td><td>The input string to search for matches</td></tr>
</tbody></table>
</div>
<h2 id="return-value-3"><a class="header" href="#return-value-3">Return Value</a></h2>
<p><strong>Type</strong>: <code>Result.Result&lt;Iter.Iter&lt;Match&gt;, RegexError&gt;</code></p>
<h3 id="success-case-2"><a class="header" href="#success-case-2">Success Case</a></h3>
<p>Returns an iterator that yields <code>Match</code> objects, where each contains:</p>
<ul>
<li>The matched substring (<code>value</code>)</li>
<li>The position of the match within the input string</li>
<li>Any captured groups</li>
<li>Match status (<code>#FullMatch</code>)</li>
</ul>
<h3 id="error-case-2"><a class="header" href="#error-case-2">Error Case</a></h3>
<p>Returns <code>RegexError</code> (<code>#NotCompiled</code>) if the pattern failed to compile during instantiation</p>
<h3 id="iteration-process"><a class="header" href="#iteration-process">Iteration Process</a></h3>
<ol>
<li>Starts from the beginning of the input string</li>
<li>For each match found:
<ul>
<li>Yields a <code>Match</code> object</li>
<li>Advances to the position after the current match</li>
</ul>
</li>
<li>Continues until no more matches are found</li>
<li>Automatically handles the internal state between iterations</li>
</ol>
<h3 id="match-generation"><a class="header" href="#match-generation">Match Generation</a></h3>
<ul>
<li>Matches are generated one at a time as the iterator is consumed</li>
<li>Non-overlapping matches are guaranteed</li>
<li>The iteration order follows the text from left to right</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview-5"><a class="header" href="#overview-5">Overview</a></h1>
<p>The <code>Match</code> record represents the result of a pattern matching operation on text, typically used in regular expression or string matching operations. It contains detailed information about what was matched, where it was found, and any captured groups within the match.</p>
<h2 id="structure"><a class="header" href="#structure">Structure</a></h2>
<pre><code class="language-motoko">public type Match = {
    string: Text;
    value: Text;
    status: {
        #FullMatch;
        #NoMatch;
    };
    position: (Nat, Nat);
    capturedGroups: ?[(Text,Nat)];
    spans: [(Nat, Nat)];
    lastIndex: Nat;
};
</code></pre>
<h2 id="field-descriptions"><a class="header" href="#field-descriptions">Field Descriptions</a></h2>
<h3 id="string-text"><a class="header" href="#string-text">string: Text</a></h3>
<p>The original input string that was searched for matches. This field preserves the complete text that was analyzed during the matching operation.</p>
<h3 id="value-text"><a class="header" href="#value-text">value: Text</a></h3>
<p>The actual matched substring found in the original text. This represents the specific portion of text that satisfied the matching criteria.</p>
<h3 id="status"><a class="header" href="#status">status</a></h3>
<p>An enumerated type that indicates the match result:</p>
<ul>
<li><code>#FullMatch</code>: Indicates a successful match was found</li>
<li><code>#NoMatch</code>: Indicates no match was found in the input string</li>
</ul>
<h3 id="position-nat-nat"><a class="header" href="#position-nat-nat">position: (Nat, Nat)</a></h3>
<p>A tuple containing the start and end indices of the match in the original string:</p>
<ul>
<li>First value: Starting index of the match</li>
<li>Second value: Ending index of the match</li>
</ul>
<h3 id="capturedgroups-textnat"><a class="header" href="#capturedgroups-textnat">capturedGroups: ?[(Text,Nat)]</a></h3>
<p>An optional array of tuples containing captured groups from the match:</p>
<ul>
<li>Each tuple contains:
<ul>
<li>Text: The captured text</li>
<li>Nat: The index of the captured group</li>
</ul>
</li>
<li><code>null</code> if no groups were captured</li>
</ul>
<h3 id="spans-nat-nat"><a class="header" href="#spans-nat-nat">spans: [(Nat, Nat)]</a></h3>
<p>An array of tuples representing the character spans of the respective match</p>
<h3 id="lastindex-nat"><a class="header" href="#lastindex-nat">lastIndex: Nat</a></h3>
<p>The index where the last match ended. This is particularly useful when performing multiple sequential matches on the same text.</p>
<h2 id="usage-examples"><a class="header" href="#usage-examples">Usage Examples</a></h2>
<h3 id="basic-match-checking"><a class="header" href="#basic-match-checking">Basic Match Checking</a></h3>
<pre><code class="language-motoko">if (matchResult.status == #FullMatch) {
    Debug.print("Found match: " # matchResult.value);
} else {
    Debug.print("No match found");
};
</code></pre>
<h3 id="working-with-captured-groups"><a class="header" href="#working-with-captured-groups">Working with Captured Groups</a></h3>
<pre><code class="language-motoko">switch (matchResult.capturedGroups) {
    case (null) { Debug.print("No groups captured") };
    case (?groups) {
        for ((text, index) in groups.vals()) {
            Debug.print("Group " # debug_show(index) # ": " # text);
        };
    };
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="regex-examples-for-motoko-regex-engine"><a class="header" href="#regex-examples-for-motoko-regex-engine">Regex Examples for Motoko Regex Engine</a></h1>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="examples.html#regex-examples-for-motoko-regex-engine">Regex Examples for Motoko Regex Engine</a>
<ul>
<li><a href="examples.html#table-of-contents">Table of Contents</a></li>
<li><a href="examples.html#internet-computer-identifiers">Internet Computer Identifiers</a>
<ul>
<li><a href="examples.html#principal-id">Principal ID</a></li>
<li><a href="examples.html#account-id">Account ID</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="internet-computer-identifiers"><a class="header" href="#internet-computer-identifiers">Internet Computer Identifiers</a></h2>
<h3 id="principal-id"><a class="header" href="#principal-id">Principal ID</a></h3>
<p>Pattern to validate Principal ID format.</p>
<pre><code class="language-motoko">// Anonymous Principal will be rejected
let principalPattern = Regex.Regex("^[a-z0-9]{5}-[a-z0-9]{5}-[a-z0-9]{5}-[a-z0-9]{5}-[a-z0-9]{3}$", null);
public func validatePrincipalId(id: Text): Bool {
    switch(principalPattern.match(id)) {
        case (#ok(result)) {
            switch(result.status) {
                case (#FullMatch) true;
                case (#NoMatch) false;
            };
        };
        case (#err(_)) false;
    };
};
</code></pre>
<h3 id="account-id"><a class="header" href="#account-id">Account ID</a></h3>
<p>Pattern to validate Account ID format.</p>
<pre><code class="language-motoko">// Account ID (32 bytes in hexadecimal)
let accountPattern = Regex.Regex("^[0-9a-f]{64}$", null);
public func validateAccountId(id: Text): Bool {
    switch(accountPattern.match(id)) {
        case (#ok(result)) {
            switch(result.status) {
                case (#FullMatch) true;
                case (#NoMatch) false;
            };
        };
        case (#err(_)) false;
    };
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-to-motoko-regex-engine"><a class="header" href="#contributing-to-motoko-regex-engine">Contributing to Motoko Regex Engine</a></h1>
<p>Thank you for your interest in contributing to the Motoko Regex Engine project! This guide will help you get started with contributing to the project.</p>
<h2 id="table-of-contents-1"><a class="header" href="#table-of-contents-1">Table of Contents</a></h2>
<ul>
<li><a href="contributing.html#contributing-to-motoko-regex-engine">Contributing to Motoko Regex Engine</a>
<ul>
<li><a href="contributing.html#table-of-contents">Table of Contents</a></li>
<li><a href="contributing.html#getting-started">Getting Started</a></li>
<li><a href="contributing.html#development-process">Development Process</a></li>
<li><a href="contributing.html#commit-guidelines">Commit Guidelines</a></li>
<li><a href="contributing.html#pull-request-process">Pull Request Process</a></li>
<li><a href="contributing.html#testing-requirements">Testing Requirements</a></li>
</ul>
</li>
</ul>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<ol>
<li>
<p>Fork the repository:</p>
<ul>
<li>Visit <a href="https://github.com/Demali-876/motoko_regex_engine">https://github.com/Demali-876/motoko_regex_engine</a></li>
<li>Click the "Fork" button in the top-right corner</li>
</ul>
</li>
<li>
<p>Clone your fork:</p>
<pre><code class="language-bash">git clone https://github.com/YOUR-USERNAME/motoko_regex_engine.git
cd motoko_regex_engine
</code></pre>
</li>
<li>
<p>Add the upstream repository:</p>
<pre><code class="language-bash">git remote add upstream https://github.com/Demali-876/motoko_regex_engine.git
</code></pre>
</li>
<li>
<p>Create a new branch for your work:</p>
<pre><code class="language-bash">git checkout -b feat/your-feature-name
</code></pre>
</li>
</ol>
<h2 id="development-process"><a class="header" href="#development-process">Development Process</a></h2>
<ol>
<li>
<p>Set up your development environment:</p>
<ul>
<li>Install the DFINITY SDK (dfx)</li>
<li>Install Node.js and npm</li>
<li>Run <code>npm install</code> to install dependencies</li>
</ul>
</li>
<li>
<p>Make your changes:</p>
<ul>
<li>Keep your changes focused and concise</li>
<li>Update documentation if needed</li>
</ul>
</li>
<li>
<p>Keep your fork up to date:</p>
<pre><code class="language-bash">git fetch upstream
git rebase upstream/main
</code></pre>
</li>
</ol>
<h2 id="commit-guidelines"><a class="header" href="#commit-guidelines">Commit Guidelines</a></h2>
<p>We use <a href="https://www.conventionalcommits.org/">Conventional Commits</a> for clear and standardized commit messages. Each commit message should be structured as follows:</p>
<pre><code>&lt;type&gt;[optional scope]: &lt;description&gt;

[optional body]

[optional footer(s)]
</code></pre>
<p>Types:</p>
<ul>
<li><code>feat</code>: A new feature</li>
<li><code>fix</code>: A bug fix</li>
<li><code>docs</code>: Documentation only changes</li>
<li><code>style</code>: Changes that do not affect the meaning of the code</li>
<li><code>refactor</code>: A code change that neither fixes a bug nor adds a feature</li>
<li><code>perf</code>: A code change that improves performance</li>
<li><code>test</code>: Adding missing tests or correcting existing tests</li>
<li><code>chore</code>: Changes to the build process or auxiliary tools</li>
</ul>
<p>Examples:</p>
<pre><code>feat(parser): add support for lookahead assertions

fix(matcher): resolve infinite loop in nested groups

docs: update API documentation for search method

refactor(compiler): simplify NFA construction logic
</code></pre>
<h2 id="pull-request-process"><a class="header" href="#pull-request-process">Pull Request Process</a></h2>
<ol>
<li>
<p>Push your changes to your fork:</p>
<pre><code class="language-bash">git push origin feat/your-feature-name
</code></pre>
</li>
<li>
<p>Create a Pull Request:</p>
<ul>
<li>Go to <a href="https://github.com/Demali-876/motoko_regex_engine/pulls">https://github.com/Demali-876/motoko_regex_engine/pulls</a></li>
<li>Click "New Pull Request"</li>
<li>Select your fork and branch</li>
<li>Fill out the PR template with:
<ul>
<li>Clear description of changes</li>
<li>Any breaking changes</li>
<li>Evidence of testing (screenshots, console output, etc.)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>PR Review Process:</p>
<ul>
<li>Maintainers will review your PR</li>
<li>Address any requested changes</li>
<li>Once approved, your PR will be merged</li>
</ul>
</li>
</ol>
<h2 id="testing-requirements"><a class="header" href="#testing-requirements">Testing Requirements</a></h2>
<p>While formal tests are not required, you must provide evidence that you've tested your changes. This can include:</p>
<ul>
<li>Screenshots of the feature working</li>
<li>Console output showing successful execution</li>
<li>Example usage and results</li>
<li>Description of test cases you've tried</li>
</ul>
<p>Example test evidence in PR:</p>
<pre><code>Tested the new alternation operator with:
1. Simple patterns: "a|b" against "a" and "b"
2. Complex patterns: "(foo|bar)+" against "foofoobar"
3. Edge cases: "a||b" and "|a|b|"

Results:
- All patterns matched correctly
- No infinite loops or crashes
- Proper error handling for invalid patterns
</code></pre>
<p>Thank you for contributing to the Motoko Regex Engine project!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
