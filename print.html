<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to the <strong>Motoko Regex Engine Documentation</strong>, your go-to guide for leveraging the power of regular expressions in the Motoko programming language. This engine provides robust tools for pattern matching, searching, and text processing.</p>
<p>Inspired by other established regex libraries, this regex engine adapts their capabilities to meet the needs of Motoko.</p>
<hr />
<h2 id="installation-and-import"><a class="header" href="#installation-and-import">Installation and Import</a></h2>
<p>Install the Motoko Regex Engine using:</p>
<pre><code class="language-bash">mops add regex
</code></pre>
<p>Import it into your project with:</p>
<pre><code class="language-motoko">import Regex "mo:regex";
</code></pre>
<hr />
<h2 id="what-is-a-regular-expression"><a class="header" href="#what-is-a-regular-expression">What is a Regular Expression?</a></h2>
<p>A <strong>regular expression</strong> (regex) is a sequence of characters defining a search pattern. Regex is widely used in text processing for tasks such as:</p>
<ul>
<li>Searching for text patterns (e.g., keywords in a document).</li>
<li>Validating formats (e.g., email addresses or phone numbers).</li>
<li>Extracting data from structured text (e.g., logs or CSV files).</li>
</ul>
<p>For example, the regex <code>^\d{3}-\d{2}-\d{4}$</code> matches a string formatted as a Social Security Number, such as <code>123-45-6789</code>.</p>
<hr />
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<h3 id="pattern-support"><a class="header" href="#pattern-support">Pattern Support</a></h3>
<ul>
<li><strong>Anchors</strong>: <code>^</code> (start of string), <code>$</code> (end of string).</li>
<li><strong>Character classes</strong>: <code>[a-z]</code>, <code>[^0-9]</code>.</li>
<li><strong>Quantifiers</strong>: <code>*</code>, <code>+</code>, <code>?</code>, <code>{m,n}</code>.</li>
<li><strong>Groups</strong>: <code>()</code>, <code>(?:)</code>.</li>
<li><strong>Alternation</strong>: <code>|</code> (logical OR).</li>
<li><strong>Escapes</strong>: <code>\d</code>, <code>\w</code>, <code>\s</code>, etc.</li>
</ul>
<h3 id="flags"><a class="header" href="#flags">Flags</a></h3>
<p>Flags are optional boolean values that modify the behavior of regex matching. They are set during instantiation and cannot be changed afterward. The engine currently supports:</p>
<ul>
<li><strong><code>caseSensitive</code></strong>: Case-sensitive matching (default is true).</li>
<li><strong><code>multiline</code></strong>: Enables multiline matching.</li>
</ul>
<p>Example with null flags (default behavior):</p>
<pre><code class="language-motoko">let regex = Regex.Regex("\d{3}-\d{2}-\d{4}", null);
</code></pre>
<h3 id="api-functions"><a class="header" href="#api-functions">API Functions</a></h3>
<ul>
<li><strong><code>match</code></strong>: Check for a full match of the pattern in the input text.</li>
<li><strong><code>search</code></strong>: Locate the first occurrence of the pattern in the input.</li>
<li><strong><code>findAll</code></strong>: Retrieve all matches for the pattern.</li>
<li><strong><code>findIter</code></strong>: Iterate over matches.</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="syntax"><a class="header" href="#syntax">Syntax</a></h1>
<ul>
<li><a href="syntax.html#syntax">Syntax</a>
<ul>
<li><a href="syntax.html#supported-syntax">Supported Syntax</a></li>
<li><a href="syntax.html#quantifiers">Quantifiers</a>
<ul>
<li><a href="syntax.html#supported-quantifiers">Supported Quantifiers</a></li>
<li><a href="syntax.html#quantifier-modes">Quantifier Modes</a></li>
<li><a href="syntax.html#invalid-quantifiers">Invalid Quantifiers</a></li>
</ul>
</li>
<li><a href="syntax.html#metacharacters">Metacharacters</a></li>
<li><a href="syntax.html#character-classes">Character Classes</a>
<ul>
<li><a href="syntax.html#nested-quantifiers">Nested Quantifiers</a></li>
</ul>
</li>
<li><a href="syntax.html#anchors">Anchors</a></li>
<li><a href="syntax.html#groups-and-group-modifiers">Groups and Group Modifiers</a>
<ul>
<li><a href="syntax.html#supported-group-modifiers">Supported Group Modifiers</a></li>
</ul>
</li>
<li><a href="syntax.html#escaped-characters">Escaped Characters</a></li>
<li><a href="syntax.html#prohibited-patterns">Prohibited Patterns</a></li>
<li><a href="syntax.html#error-handling">Error Handling</a>
<ul>
<li><a href="syntax.html#error-types">Error Types</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<h2 id="supported-syntax"><a class="header" href="#supported-syntax">Supported Syntax</a></h2>
<p>Motoko regex supports a variety of syntax features for defining patterns. These include:</p>
<ul>
<li>Character matching (<code>a</code>, <code>b</code>, <code>c</code>, etc.)</li>
<li>Alternation (<code>|</code>)</li>
<li>Grouping (<code>()</code>)</li>
<li>Character classes (<code>[]</code> with support for ranges like <code>[a-z]</code>)</li>
<li>Quantifiers (<code>*</code>, <code>+</code>, <code>?</code>, <code>{n}</code>, <code>{n,m}</code>)</li>
<li>Anchors (<code>^</code>, <code>$</code>)</li>
</ul>
<hr />
<h2 id="quantifiers"><a class="header" href="#quantifiers">Quantifiers</a></h2>
<p>Quantifiers specify how many times a preceding element must occur for a match.</p>
<h3 id="supported-quantifiers"><a class="header" href="#supported-quantifiers">Supported Quantifiers</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Quantifier</th><th>Meaning</th><th>Example</th></tr></thead><tbody>
<tr><td><code>*</code></td><td>Match 0 or more times</td><td><code>a*</code> matches "", "a", "aaa"</td></tr>
<tr><td><code>+</code></td><td>Match 1 or more times</td><td><code>a+</code> matches "a", "aaa"</td></tr>
<tr><td><code>?</code></td><td>Match 0 or 1 time</td><td><code>a?</code> matches "", "a"</td></tr>
<tr><td><code>{n}</code></td><td>Match exactly <code>n</code> times</td><td><code>a{2}</code> matches "aa"</td></tr>
<tr><td><code>{n,}</code></td><td>Match at least <code>n</code> times</td><td><code>a{2,}</code> matches "aa", "aaa"</td></tr>
<tr><td><code>{n,m}</code></td><td>Match between <code>n</code> and <code>m</code> times</td><td><code>a{2,4}</code> matches "aa", "aaa", "aaaa"</td></tr>
</tbody></table>
</div>
<h3 id="quantifier-modes"><a class="header" href="#quantifier-modes">Quantifier Modes</a></h3>
<p>Quantifiers can operate in different modes:</p>
<ul>
<li><strong>Greedy:</strong> Matches as many occurrences as possible.</li>
<li><strong>Lazy (<code>?</code> after quantifier):</strong> Matches as few as possible. E.g., <code>a+?</code> matches fewer occurrences of "a".</li>
</ul>
<h3 id="invalid-quantifiers"><a class="header" href="#invalid-quantifiers">Invalid Quantifiers</a></h3>
<p>Certain quantifier patterns are not allowed:</p>
<ul>
<li>Redundant modifiers, such as <code>a{2}+</code> or <code>a{2}*</code>.</li>
<li>Empty quantifiers, e.g., <code>{}</code> or <code>{,}</code>.</li>
<li>Multiple commas in ranges, e.g., <code>{2,,4}</code>.</li>
</ul>
<hr />
<h2 id="metacharacters"><a class="header" href="#metacharacters">Metacharacters</a></h2>
<p>Metacharacters represent special patterns or symbols.</p>
<div class="table-wrapper"><table><thead><tr><th>Metacharacter</th><th>Meaning</th><th>Example</th></tr></thead><tbody>
<tr><td><code>.</code></td><td>Match any character except <code>\n</code></td><td><code>a.b</code> matches "acb"</td></tr>
<tr><td><code>\w</code></td><td>Match word characters (alphanumeric + <code>_</code>)</td><td><code>\w+</code> matches "abc123"</td></tr>
<tr><td><code>\W</code></td><td>Match non-word characters</td><td><code>\W</code> matches "@"</td></tr>
<tr><td><code>\d</code></td><td>Match digits (<code>0-9</code>)</td><td><code>\d+</code> matches "123"</td></tr>
<tr><td><code>\D</code></td><td>Match non-digits</td><td><code>\D</code> matches "a"</td></tr>
<tr><td><code>\s</code></td><td>Match whitespace</td><td><code>\s+</code> matches "   "</td></tr>
<tr><td><code>\S</code></td><td>Match non-whitespace</td><td><code>\S</code> matches "a"</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="character-classes"><a class="header" href="#character-classes">Character Classes</a></h2>
<p>Character classes allow matching sets of characters.</p>
<ul>
<li><code>[abc]</code>: Matches any character <code>a</code>, <code>b</code>, or <code>c</code>.</li>
<li><code>[^abc]</code>: Matches any character except <code>a</code>, <code>b</code>, or <code>c</code>.</li>
<li><code>[a-z]</code>: Matches any character in the range <code>a</code> to <code>z</code>.</li>
</ul>
<h3 id="nested-quantifiers"><a class="header" href="#nested-quantifiers">Nested Quantifiers</a></h3>
<p>Quantifiers inside character classes must be explicitly defined. Nested or redundant quantifiers, like <code>[a-z]{2}+</code>, are not allowed.</p>
<hr />
<h2 id="anchors"><a class="header" href="#anchors">Anchors</a></h2>
<p>Anchors specify positions in the text.</p>
<div class="table-wrapper"><table><thead><tr><th>Anchor</th><th>Meaning</th><th>Example</th></tr></thead><tbody>
<tr><td><code>^</code></td><td>Start of the string</td><td><code>^abc</code> matches "abc" at the beginning</td></tr>
<tr><td><code>$</code></td><td>End of the string</td><td><code>abc$</code> matches "abc" at the end</td></tr>
<tr><td><code>\b</code></td><td>Word boundary</td><td><code>\bword\b</code> matches "word"</td></tr>
<tr><td><code>\B</code></td><td>Non-word boundary</td><td><code>\Bword</code> matches "word" not at a boundary</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="groups-and-group-modifiers"><a class="header" href="#groups-and-group-modifiers">Groups and Group Modifiers</a></h2>
<p>Groups are enclosed in parentheses <code>()</code> and can be modified for specific behaviors.</p>
<h3 id="supported-group-modifiers"><a class="header" href="#supported-group-modifiers">Supported Group Modifiers</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Modifier</th><th>Syntax</th><th>Meaning</th></tr></thead><tbody>
<tr><td>Non-capturing</td><td><code>(?:...)</code></td><td>Groups without capturing</td></tr>
<tr><td>Positive Lookahead</td><td><code>(?=...)</code></td><td>Asserts that what follows matches</td></tr>
<tr><td>Negative Lookahead</td><td><code>(?!...)</code></td><td>Asserts that what follows does not match</td></tr>
<tr><td>Positive Lookbehind</td><td><code>(?&lt;=...)</code></td><td>Asserts that what precedes matches</td></tr>
<tr><td>Negative Lookbehind</td><td><code>(?&lt;!...)</code></td><td>Asserts that what precedes does not match</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="escaped-characters"><a class="header" href="#escaped-characters">Escaped Characters</a></h2>
<p>Escape sequences represent special characters.</p>
<div class="table-wrapper"><table><thead><tr><th>Escape Sequence</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>\\</code></td><td>Literal backslash</td></tr>
<tr><td><code>\n</code></td><td>Newline</td></tr>
<tr><td><code>\t</code></td><td>Tab</td></tr>
<tr><td><code>\w</code>, <code>\W</code></td><td>Word/Non-word characters</td></tr>
<tr><td><code>\d</code>, <code>\D</code></td><td>Digit/Non-digit</td></tr>
<tr><td><code>\s</code>, <code>\S</code></td><td>Whitespace/Non-whitespace</td></tr>
</tbody></table>
</div>
<p>Invalid escape sequences throw an error.</p>
<hr />
<h2 id="prohibited-patterns"><a class="header" href="#prohibited-patterns">Prohibited Patterns</a></h2>
<ul>
<li>Invalid group modifiers: e.g., <code>(?)</code>.</li>
<li>Empty groups: <code>()</code> is not allowed.</li>
<li>Empty character classes: <code>[]</code> results in an error.</li>
<li>Redundant or conflicting quantifiers: <code>a{2}+</code>.</li>
</ul>
<hr />
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<p>The Motoko regex engine provides detailed error feedback to help developers identify and fix issues in their regular expressions. Below is a list of all possible errors, their meanings, and typical scenarios where they might occur.</p>
<h3 id="error-types"><a class="header" href="#error-types">Error Types</a></h3>
<div class="table-wrapper"><table><thead><tr><th><strong>Error</strong></th><th><strong>Description</strong></th><th><strong>Cause</strong></th></tr></thead><tbody>
<tr><td><strong><code>#UnexpectedCharacter</code></strong></td><td>An invalid character was encountered during parsing.</td><td>Using a character that is not allowed in regex syntax, such as unescaped special characters.</td></tr>
<tr><td><strong><code>#UnexpectedEndOfInput</code></strong></td><td>The regex input ended unexpectedly, leaving constructs incomplete.</td><td>Omitting closing brackets, parentheses, or quantifier ranges.</td></tr>
<tr><td><strong><code>#GenericError</code></strong></td><td>A generic error message providing additional context.</td><td>Various syntax or logic errors not covered by specific error types.</td></tr>
<tr><td><strong><code>#InvalidQuantifierRange</code></strong></td><td>A malformed or invalid quantifier range was used.</td><td>Using invalid quantifier syntax, e.g., <code>{,}</code>, <code>{,3}</code>, <code>{a,b}</code>.</td></tr>
<tr><td><strong><code>#InvalidEscapeSequence</code></strong></td><td>An invalid escape sequence was encountered.</td><td>Using unrecognized escape sequences like <code>\q</code> or <code>\x</code> without proper syntax.</td></tr>
<tr><td><strong><code>#UnmatchedParenthesis</code></strong></td><td>A closing parenthesis <code>)</code> does not match any preceding opening parenthesis <code>(</code>.</td><td>Missing or extra closing parentheses in the regex pattern.</td></tr>
<tr><td><strong><code>#MismatchedParenthesis</code></strong></td><td>Parentheses do not form a valid pairing.</td><td>Nested parentheses are incorrectly matched or unbalanced, e.g., <code>((a)b])</code>.</td></tr>
<tr><td><strong><code>#UnexpectedToken</code></strong></td><td>An unexpected token was encountered during parsing.</td><td>Using misplaced or unrecognized tokens in the regex pattern.</td></tr>
<tr><td><strong><code>#UnclosedGroup</code></strong></td><td>A group construct is not properly closed with a closing parenthesis <code>)</code>.</td><td>Missing a closing parenthesis in a group definition.</td></tr>
<tr><td><strong><code>#InvalidQuantifier</code></strong></td><td>A quantifier is malformed or applied in an invalid context.</td><td>Using redundant or conflicting quantifiers, e.g., <code>a{2}+</code>.</td></tr>
<tr><td><strong><code>#EmptyExpression</code></strong></td><td>The regex input is empty or contains no valid expressions.</td><td>Providing an empty string or expression with no meaningful content.</td></tr>
<tr><td><strong><code>#NotCompiled</code></strong></td><td>The regex has not been compiled before attempting to use it.</td><td>There was an error during compilation of the reject object, this may be due to any of the previous errors. That error will be specified in the <code>#NotCompiled</code> variant.</td></tr>
</tbody></table>
</div>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="flags-1"><a class="header" href="#flags-1">Flags</a></h1>
<p>Flags in Motoko regex provide flexibility by modifying the behavior of the regex matching process. This section covers the available flags, their purpose, and how to use them effectively.</p>
<hr />
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Flags are optional parameters that can alter how the regex engine interprets and processes a pattern. They enable features such as case-insensitive matching and handling multiline inputs.</p>
<hr />
<h2 id="available-flags"><a class="header" href="#available-flags">Available Flags</a></h2>
<h3 id="1-case_sensitive"><a class="header" href="#1-case_sensitive"><strong>1. CASE_SENSITIVE</strong></a></h3>
<ul>
<li>
<p><strong>Type:</strong> <code>Bool</code></p>
</li>
<li>
<p><strong>Default:</strong> <code>true</code></p>
</li>
<li>
<p><strong>Description:</strong> Determines whether the regex should consider case when matching characters.</p>
</li>
<li>
<p><strong>Behavior:</strong></p>
<ul>
<li>When <code>caseSensitive = true</code>: Matches are case-sensitive (default behavior).</li>
<li>When <code>caseSensitive = false</code>: Matches are case-insensitive, treating uppercase and lowercase letters as equivalent.</li>
</ul>
</li>
<li>
<p><strong>Example:</strong></p>
<pre><code class="language-motoko">let regex = Regex.Regex("abc", ?{caseSensitive = false});
assert(regex.search("ABC") == #FullMatch);
</code></pre>
</li>
</ul>
<h3 id="2-multiline"><a class="header" href="#2-multiline"><strong>2. MULTILINE</strong></a></h3>
<ul>
<li>
<p><strong>Type:</strong> <code>Bool</code></p>
</li>
<li>
<p><strong>Default:</strong> <code>false</code></p>
</li>
<li>
<p><strong>Description:</strong> Alters the behavior of anchors (<code>^</code> and <code>$</code>) to match at line boundaries rather than the start or end of the entire string.</p>
</li>
<li>
<p><strong>Behavior:</strong></p>
<ul>
<li>When <code>multiline = true</code>:
<ul>
<li><code>^</code> matches the start of any line.</li>
<li><code>$</code> matches the end of any line.</li>
</ul>
</li>
<li>When <code>multiline = false</code> (default behavior):
<ul>
<li><code>^</code> matches the beginning of the entire input.</li>
<li><code>$</code> matches the end of the entire input.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Example:</strong></p>
<pre><code class="language-motoko">let regex = Regex.Regex("^abc$", ?{multiline = true});
assert(regex.search("abc\ndef\nabc") == #FullMatch);
</code></pre>
</li>
</ul>
<hr />
<h2 id="combining-flags"><a class="header" href="#combining-flags">Combining Flags</a></h2>
<p>You can combine flags to fine-tune the regex engine's behavior. For example:</p>
<pre><code class="language-motoko">let regex = Regex.Regex("abc", ?{caseSensitive = false; multiline = true});
assert(regex.search("ABC\ndef\nabc") == #FullMatch);
</code></pre>
<p>In this example:</p>
<ul>
<li>The pattern <code>abc</code> is matched regardless of case.</li>
<li>The engine processes each line independently due to <code>multiline = true</code>.</li>
</ul>
<hr />
<h2 id="default-behavior-without-flags"><a class="header" href="#default-behavior-without-flags">Default Behavior Without Flags</a></h2>
<p>If no flags are specified, the engine uses the following defaults:</p>
<ul>
<li><code>caseSensitive = true</code></li>
<li><code>multiline = false</code></li>
</ul>
<p>This means:</p>
<ul>
<li>Matching is case-sensitive.</li>
<li>Anchors (<code>^</code> and <code>$</code>) match only at the start and end of the entire input.</li>
</ul>
<hr />
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<ul>
<li>Use <code>caseSensitive = false</code> for patterns that need to ignore case differences, such as matching user inputs in a case-insensitive manner.</li>
<li>Use <code>multiline = true</code> when processing multi-line text, such as logs or formatted documents, where each line might have independent matching requirements.</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>This section provides an overview of the (current) functions available in this library. Use the links below to navigate to detailed documentation for each function.</p>
<ul>
<li><a href="functions/search.html">search()</a></li>
<li><a href="functions/match.html">match()</a></li>
<li><a href="functions/findall.html">findAll()</a></li>
<li><a href="functions/finditer.html">findIter()</a></li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview-1"><a class="header" href="#overview-1">Overview</a></h1>
<p>The <code>search()</code> function scans an input string for the first occurrence of the regex pattern. Unlike <code>match()</code>, which requires the pattern to span the entire input, <code>search()</code> identifies the first substring that satisfies the pattern.</p>
<h2 id="signature"><a class="header" href="#signature">Signature</a></h2>
<pre><code class="language-motoko">public func search(text: Text): Result.Result&lt;Match, RegexError&gt;
</code></pre>
<h2 id="parameters"><a class="header" href="#parameters">Parameters</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>text</td><td>Text</td><td>The input string to search for the first match</td></tr>
</tbody></table>
</div>
<h2 id="return-value"><a class="header" href="#return-value">Return Value</a></h2>
<p><strong>Type</strong>: <code>Result.Result&lt;Match, RegexError&gt;</code></p>
<h3 id="success-case"><a class="header" href="#success-case">Success Case</a></h3>
<p>Returns a <code>Match</code> object containing:</p>
<ul>
<li>The matched substring (<code>value</code>)</li>
<li>The position of the match within the input string</li>
<li>Captured groups (if any)</li>
</ul>
<h3 id="no-match-case"><a class="header" href="#no-match-case">No Match Case</a></h3>
<p>Returns a <code>Match</code> object with:</p>
<ul>
<li><code>status = #NoMatch</code></li>
<li>Empty <code>value</code></li>
</ul>
<h3 id="error-case"><a class="header" href="#error-case">Error Case</a></h3>
<p>Returns <code>RegexError</code> (<code>#NotCompiled</code>) only if the pattern failed to compile during instantiation</p>
<h2 id="behavior"><a class="header" href="#behavior">Behavior</a></h2>
<h3 id="input-validation"><a class="header" href="#input-validation">Input Validation</a></h3>
<ul>
<li>If the regex instantiation failed (due to an invalid pattern), returns <code>RegexError</code> (<code>#NotCompiled</code>)</li>
</ul>
<h3 id="search-process"><a class="header" href="#search-process">Search Process</a></h3>
<ol>
<li>Scans the input string character by character</li>
<li>Identifies if a potential match could begin at the current position</li>
<li>Delegates to <code>match()</code> for full matching starting from that position</li>
</ol>
<h3 id="result-construction"><a class="header" href="#result-construction">Result Construction</a></h3>
<ul>
<li>On finding a match:
<ul>
<li>Returns a <code>Match</code> object with details of the match</li>
</ul>
</li>
<li>If no match is found after scanning the string:
<ul>
<li>Returns a <code>Match</code> object with <code>status = #NoMatch</code></li>
</ul>
</li>
</ul>
<h2 id="example-usage"><a class="header" href="#example-usage">Example Usage</a></h2>
<h3 id="1-successful-match"><a class="header" href="#1-successful-match">1. Successful Match</a></h3>
<p><strong>Pattern</strong>: <code>"a+"</code> <strong>Input</strong>: <code>"xxaaayy"</code></p>
<pre><code class="language-motoko">let pattern = Regex.Regex("a+", null);
let result = pattern.search("xxaaayy");
switch (result) {
    case (#ok(match)) Debug.print("First match: " # match.value);  // Output: "aaa"
    case (#err(error)) Debug.print("Error: " # debug_show(error));
};
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code>First match: aaa
</code></pre>
<h3 id="2-no-match-found"><a class="header" href="#2-no-match-found">2. No Match Found</a></h3>
<p><strong>Pattern</strong>: <code>"z+"</code> <strong>Input</strong>: <code>"xxaaaayy"</code></p>
<pre><code class="language-motoko">let pattern = Regex.Regex("z+", null);
let result = pattern.search("xxaaaayy");
switch (result) {
    case (#ok(match)) {
        switch (match.status) {
            case (#NoMatch) Debug.print("No match found.");
            case (#FullMatch) Debug.print("First match: " # match.value);
        };
    };
    case (#err(error)) Debug.print("Error: " # debug_show(error));
};
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code>No match found.
</code></pre>
<h3 id="3-invalid-pattern"><a class="header" href="#3-invalid-pattern">3. Invalid Pattern</a></h3>
<p><strong>Scenario</strong>: Creating a regex with an invalid pattern</p>
<pre><code class="language-motoko">let pattern = Regex.Regex("[a-");
let result = pattern.search("xxaaaayy");
switch (result) {
    case (#ok(match)) Debug.print("First match: " # match.value);
    case (#err(error)) Debug.print("Error: " # debug_show(error)); // Output: #NotCompiled
};
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code>Error: #NotCompiled
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview-2"><a class="header" href="#overview-2"><strong>Overview</strong></a></h1>
<p>The <code>match()</code> function is a core API for performing regex-based matching. It takes an input string and matches it against a precompiled regex represented as an NFA. The function handles matching mechanics, including state transitions, greedy and lazy quantifiers, and group captures.</p>
<hr />
<h2 id="signature-1"><a class="header" href="#signature-1"><strong>Signature</strong></a></h2>
<pre><code class="language-motoko">public func match(text: Text): Result.Result&lt;Match, RegexError&gt;
</code></pre>
<hr />
<h3 id="parameters-1"><a class="header" href="#parameters-1"><strong>Parameters</strong></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>text</code></td><td><code>Text</code></td><td>The input string to be matched against the compiled regex.</td></tr>
</tbody></table>
</div>
<hr />
<h3 id="return-value-1"><a class="header" href="#return-value-1"><strong>Return Value</strong></a></h3>
<p><code>Result.Result&lt;Match, RegexError&gt;</code>:</p>
<ul>
<li><strong>On Success</strong> (<code>Match</code>):
<ul>
<li>Contains details of the match, such as the matched substring, captured groups, and spans.</li>
</ul>
</li>
<li><strong>On Failure</strong> (<code>RegexError</code>):
<ul>
<li>Indicates why the matching process failed (e.g., regex not compiled).</li>
</ul>
</li>
</ul>
<hr />
<h3 id="behavior-1"><a class="header" href="#behavior-1"><strong>Behavior</strong></a></h3>
<ol>
<li>
<p><strong>Input Validation</strong>:</p>
<ul>
<li>Checks if the regex has been compiled.</li>
<li>Returns <code>#NotCompiled</code> error if the regex is unavailable.</li>
</ul>
</li>
<li>
<p><strong>Matching Process</strong>:</p>
<ul>
<li>Delegates the actual matching logic to the <code>matcher.match</code> function.</li>
<li>Traverses the NFA based on input characters.</li>
<li>Respects greedy and lazy quantifier modes.</li>
<li>Handles capture groups and anchors (e.g., <code>^</code>, <code>$</code>).</li>
</ul>
</li>
<li>
<p><strong>Result Construction</strong>:</p>
<ul>
<li>Builds a <code>Match</code> object for successful matches.</li>
<li>Returns <code>RegexError</code> for failures.</li>
</ul>
</li>
</ol>
<hr />
<h3 id="example-usage-1"><a class="header" href="#example-usage-1"><strong>Example Usage</strong></a></h3>
<h4 id="1-successful-match-1"><a class="header" href="#1-successful-match-1"><strong>1. Successful Match</strong></a></h4>
<pre><code class="language-motoko">let pattern = Regex.Regex("h.*o",null); 
let result = pattern.match("hello");

switch (result) {
  case (#ok(match)) {
    Debug.print("Matched value: " # match.value);
  };
  case (#err(error)) {
    Debug.print("Error: " # debug_show(error));
  };
}
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code>Matched value: hello
</code></pre>
<hr />
<h4 id="2-no-match"><a class="header" href="#2-no-match"><strong>2. No Match</strong></a></h4>
<pre><code class="language-motoko">let pattern = Regex.Regex("z+",null);
let result = pattern.match("hello");

switch (result) {
  case (#ok(match)) {
    Debug.print("Matched value: " # match.value);
  };
  case (#err(error)) {
    Debug.print("Error: " # debug_show(error));
  };
}
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code>#ok: status = #NoMatch
</code></pre>
<hr />
<h4 id="input-validation-1"><a class="header" href="#input-validation-1"><strong>Input Validation</strong></a></h4>
<ul>
<li>
<p>Before matching, the function ensures the regex is compiled.</p>
</li>
<li>
<p>If <code>nfa</code> is <code>null</code>, the function returns:</p>
<pre><code class="language-motoko">#err(#NotCompiled)
</code></pre>
</li>
</ul>
<hr />
<h4 id="delegation-to-matchermatch"><a class="header" href="#delegation-to-matchermatch"><strong>Delegation to <code>matcher.match</code></strong></a></h4>
<ul>
<li>The compiled NFA, input <code>text</code>, and optional <code>flags</code> are passed to <code>matcher.match</code>.</li>
<li><code>matcher.match</code> performs:
<ul>
<li><strong>State Transitions</strong>:
<ul>
<li>Moves between states in the NFA based on input characters.</li>
</ul>
</li>
<li><strong>Greedy and Lazy Quantifiers</strong>:
<ul>
<li>Greedy quantifiers consume as much input as possible.</li>
<li>Lazy quantifiers stop at the first valid match.</li>
</ul>
</li>
<li><strong>Capture Groups</strong>:
<ul>
<li>Tracks and extracts group matches.</li>
</ul>
</li>
<li><strong>Anchors</strong>:
<ul>
<li>Ensures patterns anchored to the start (<code>^</code>) or end (<code>$</code>) are respected.</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview-3"><a class="header" href="#overview-3">Overview</a></h1>
<p>The <code>findAll()</code> method returns an array of all non-overlapping matches of the regex pattern in the input text. Unlike <code>findIter()</code>, this method collects all matches at once into an array.</p>
<h2 id="signature-2"><a class="header" href="#signature-2">Signature</a></h2>
<pre><code class="language-motoko">public func findAll(text: Text): Result.Result&lt;[Match], RegexError&gt;
</code></pre>
<h2 id="parameters-2"><a class="header" href="#parameters-2">Parameters</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>text</td><td>Text</td><td>The input string to search for matches</td></tr>
</tbody></table>
</div>
<h2 id="return-value-2"><a class="header" href="#return-value-2">Return Value</a></h2>
<p><strong>Type</strong>: <code>Result.Result&lt;[Match], RegexError&gt;</code></p>
<h3 id="success-case-1"><a class="header" href="#success-case-1">Success Case</a></h3>
<p>Returns an array of <code>Match</code> objects, where each contains:</p>
<ul>
<li>The matched substring (<code>value</code>)</li>
<li>The position of the match within the input string</li>
<li>Any captured groups</li>
<li>Match status (<code>#FullMatch</code>)</li>
</ul>
<h3 id="error-case-1"><a class="header" href="#error-case-1">Error Case</a></h3>
<p>Returns <code>RegexError</code> (<code>#NotCompiled</code>) if the pattern failed to compile during instantiation</p>
<h3 id="match-collection-process"><a class="header" href="#match-collection-process">Match Collection Process</a></h3>
<ol>
<li>Starts from the beginning of the input string</li>
<li>Collects all non-overlapping matches into an array</li>
<li>Preserves the order of matches as they appear in the text</li>
<li>Returns an empty array if no matches are found</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview-4"><a class="header" href="#overview-4">Overview</a></h1>
<p>The <code>findIter()</code> method returns an iterator that yields all non-overlapping matches of the regex pattern in the input text. This method is memory-efficient as it generates matches lazily instead of collecting them all at once like <code>findAll()</code>.</p>
<h2 id="signature-3"><a class="header" href="#signature-3">Signature</a></h2>
<pre><code class="language-motoko">public func findIter(text: Text): Result.Result&lt;Iter.Iter&lt;Match&gt;, RegexError&gt;
</code></pre>
<h2 id="parameters-3"><a class="header" href="#parameters-3">Parameters</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>text</td><td>Text</td><td>The input string to search for matches</td></tr>
</tbody></table>
</div>
<h2 id="return-value-3"><a class="header" href="#return-value-3">Return Value</a></h2>
<p><strong>Type</strong>: <code>Result.Result&lt;Iter.Iter&lt;Match&gt;, RegexError&gt;</code></p>
<h3 id="success-case-2"><a class="header" href="#success-case-2">Success Case</a></h3>
<p>Returns an iterator that yields <code>Match</code> objects, where each contains:</p>
<ul>
<li>The matched substring (<code>value</code>)</li>
<li>The position of the match within the input string</li>
<li>Any captured groups</li>
<li>Match status (<code>#FullMatch</code>)</li>
</ul>
<h3 id="error-case-2"><a class="header" href="#error-case-2">Error Case</a></h3>
<p>Returns <code>RegexError</code> (<code>#NotCompiled</code>) if the pattern failed to compile during instantiation</p>
<h3 id="iteration-process"><a class="header" href="#iteration-process">Iteration Process</a></h3>
<ol>
<li>Starts from the beginning of the input string</li>
<li>For each match found:
<ul>
<li>Yields a <code>Match</code> object</li>
<li>Advances to the position after the current match</li>
</ul>
</li>
<li>Continues until no more matches are found</li>
<li>Automatically handles the internal state between iterations</li>
</ol>
<h3 id="match-generation"><a class="header" href="#match-generation">Match Generation</a></h3>
<ul>
<li>Matches are generated one at a time as the iterator is consumed</li>
<li>Non-overlapping matches are guaranteed</li>
<li>The iteration order follows the text from left to right</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="replace"><a class="header" href="#replace"><strong>replace()</strong></a></h1>
<p>The <code>replace()</code> function substitutes matches in the input string with a specified replacement string. This function allows specifying a maximum number of replacements (<code>maxReplacements</code>).</p>
<hr />
<h2 id="signature-4"><a class="header" href="#signature-4"><strong>Signature</strong></a></h2>
<pre><code class="language-motoko">public func replace(text: Text, replacement: Text, maxReplacements: ?Nat): Result.Result&lt;Text, RegexError&gt;
</code></pre>
<hr />
<h3 id="parameters-4"><a class="header" href="#parameters-4"><strong>Parameters</strong></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>text</code></td><td><code>Text</code></td><td>The input string to perform replacements on.</td></tr>
<tr><td><code>replacement</code></td><td><code>Text</code></td><td>The string to replace matches with.</td></tr>
<tr><td><code>maxReplacements</code></td><td><code>?Nat</code></td><td>Optional limit on the number of replacements. If <code>null</code>, replaces all.</td></tr>
</tbody></table>
</div>
<hr />
<h3 id="return-value-4"><a class="header" href="#return-value-4"><strong>Return Value</strong></a></h3>
<p><code>Result.Result&lt;Text, RegexError&gt;</code>:</p>
<ul>
<li><strong>On Success</strong> (<code>Text</code>):
<ul>
<li>The updated string after performing replacements.</li>
</ul>
</li>
<li><strong>On Failure</strong> (<code>RegexError</code>):
<ul>
<li>Indicates why the operation failed (e.g., invalid regex or replacement).</li>
</ul>
</li>
</ul>
<hr />
<h3 id="behavior-2"><a class="header" href="#behavior-2"><strong>Behavior</strong></a></h3>
<ol>
<li>
<p><strong>Input Validation</strong>:</p>
<ul>
<li>Checks if the regex has been compiled.</li>
<li>Returns <code>#NotCompiled</code> error if unavailable.</li>
</ul>
</li>
<li>
<p><strong>Replacement Process</strong>:</p>
<ul>
<li>Matches the regex pattern in the input string.</li>
<li>Replaces each match with the specified string.</li>
<li>Respects the <code>maxReplacements</code> limit if provided.</li>
</ul>
</li>
<li>
<p><strong>Result Construction</strong>:</p>
<ul>
<li>Returns the updated string on success.</li>
<li>Returns <code>RegexError</code> for invalid inputs or uncompiled regex.</li>
</ul>
</li>
</ol>
<hr />
<h3 id="example-usage-2"><a class="header" href="#example-usage-2"><strong>Example Usage</strong></a></h3>
<h4 id="1-replace-all-matches"><a class="header" href="#1-replace-all-matches"><strong>1. Replace All Matches</strong></a></h4>
<pre><code class="language-motoko">let replaceRegex = Regex.Regex("Hello");
let result = replaceRegex.replace("Hello world, Hello universe", "Hi", null);

switch (result) {
  case (#ok(updatedText)) {
    Debug.print("Updated text: " # updatedText);
  };
  case (#err(error)) {
    Debug.print("Error: " # debug_show(error));
  };
}
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code>Updated text: Hi world, Hi universe
</code></pre>
<hr />
<h4 id="2-replace-with-limit"><a class="header" href="#2-replace-with-limit"><strong>2. Replace with Limit</strong></a></h4>
<pre><code class="language-motoko">let replaceRegex = Regex.Regex("Hello");
let result = replaceRegex.replace("Hello world, Hello universe", "Hi", ?1);

switch (result) {
  case (#ok(updatedText)) {
    Debug.print("Updated text: " # updatedText);
  };
  case (#err(error)) {
    Debug.print("Error: " # debug_show(error));
  };
}
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code>Updated text: Hi world, Hello universe
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="sub"><a class="header" href="#sub"><strong>sub()</strong></a></h1>
<p>The <code>sub()</code> function substitutes matches in the input string with a specified replacement string. Unlike <code>replace</code>, it allows the use of regex patterns in the replacement string.</p>
<hr />
<h2 id="signature-5"><a class="header" href="#signature-5"><strong>Signature</strong></a></h2>
<pre><code class="language-motoko">public func sub(text: Text, replacement: Text, maxSubstitutions: ?Nat): Result.Result&lt;Text, RegexError&gt;
</code></pre>
<hr />
<h3 id="parameters-5"><a class="header" href="#parameters-5"><strong>Parameters</strong></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>text</code></td><td><code>Text</code></td><td>The input string to perform substitutions on.</td></tr>
<tr><td><code>replacement</code></td><td><code>Text</code></td><td>The string (can include regex) to replace matches with.</td></tr>
<tr><td><code>maxSubstitutions</code></td><td><code>?Nat</code></td><td>Optional limit on the number of substitutions. If <code>null</code>, substitutes all.</td></tr>
</tbody></table>
</div>
<hr />
<h3 id="return-value-5"><a class="header" href="#return-value-5"><strong>Return Value</strong></a></h3>
<p><code>Result.Result&lt;Text, RegexError&gt;</code>:</p>
<ul>
<li><strong>On Success</strong> (<code>Text</code>):
<ul>
<li>The updated string after performing substitutions.</li>
</ul>
</li>
<li><strong>On Failure</strong> (<code>RegexError</code>):
<ul>
<li>Indicates why the operation failed (e.g., invalid regex or replacement).</li>
</ul>
</li>
</ul>
<hr />
<h3 id="behavior-3"><a class="header" href="#behavior-3"><strong>Behavior</strong></a></h3>
<ol>
<li>
<p><strong>Input Validation</strong>:</p>
<ul>
<li>Checks if the regex has been compiled.</li>
<li>Returns <code>#NotCompiled</code> error if unavailable.</li>
</ul>
</li>
<li>
<p><strong>Substitution Process</strong>:</p>
<ul>
<li>Matches the regex pattern in the input string.</li>
<li>Substitutes each match with the specified replacement string.</li>
<li>Respects the <code>maxReplacements</code> limit if provided.</li>
</ul>
</li>
<li>
<p><strong>Result Construction</strong>:</p>
<ul>
<li>Returns the updated string on success.</li>
<li>Returns <code>RegexError</code> for invalid inputs or uncompiled regex.</li>
</ul>
</li>
</ol>
<hr />
<h3 id="implementation"><a class="header" href="#implementation"><strong>Implementation</strong></a></h3>
<pre><code class="language-motoko">public func sub(text: Text, replacement: Text, maxReplacements: ?Nat): Result.Result&lt;Text, RegexError&gt; {
    switch (nfa) {
        case (null) #err(#NotCompiled);
        case (?compiledNFA) {
            matcher.sub(compiledNFA, text, replacement, maxReplacements)
        };
    }
};
</code></pre>
<hr />
<h3 id="example-usage-3"><a class="header" href="#example-usage-3"><strong>Example Usage</strong></a></h3>
<h4 id="1-substituting-all-matches"><a class="header" href="#1-substituting-all-matches"><strong>1. Substituting All Matches</strong></a></h4>
<pre><code class="language-motoko">let subRegex = Regex.Regex("\d+");
let result = subRegex.sub("I have 10 bananas and 20 apples", "many", null);

switch (result) {
  case (#ok(updatedText)) {
    Debug.print("Updated text: " # updatedText);
  };
  case (#err(error)) {
    Debug.print("Error: " # debug_show(error));
  };
}
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code>Updated text: I have many bananas and many apples
</code></pre>
<hr />
<h4 id="2-substituting-with-limit"><a class="header" href="#2-substituting-with-limit"><strong>2. Substituting with Limit</strong></a></h4>
<pre><code class="language-motoko">let subRegex = Regex.Regex("\\d+");
let result = subRegex.sub("I have 10 bananas and 20 apples", "many", ?1);

switch (result) {
  case (#ok(updatedText)) {
    Debug.print("Updated text: " # updatedText);
  };
  case (#err(error)) {
    Debug.print("Error: " # debug_show(error));
  };
}
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code>Updated text: I have many bananas and 20 apples
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="split"><a class="header" href="#split"><strong>split()</strong></a></h1>
<p>The <code>split()</code> function divides a string into substrings based on matches of the regex pattern, with an optional limit on the number of splits (<code>maxSplit</code>).</p>
<hr />
<h2 id="signature-6"><a class="header" href="#signature-6"><strong>Signature</strong></a></h2>
<pre><code class="language-motoko">public func split(text: Text, maxSplit: ?Nat): Result.Result&lt;[Text], RegexError&gt;
</code></pre>
<hr />
<h3 id="parameters-6"><a class="header" href="#parameters-6"><strong>Parameters</strong></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>text</code></td><td><code>Text</code></td><td>The input string to be split based on the regex pattern.</td></tr>
<tr><td><code>maxSplit</code></td><td><code>?Nat</code></td><td>Optional limit on the number of splits. If <code>null</code>, splits all.</td></tr>
</tbody></table>
</div>
<hr />
<h3 id="return-value-6"><a class="header" href="#return-value-6"><strong>Return Value</strong></a></h3>
<p><code>Result.Result&lt;[Text], RegexError&gt;</code>:</p>
<ul>
<li><strong>On Success</strong> (<code>[Text]</code>):
<ul>
<li>A vector of substrings resulting from splitting the input string.</li>
</ul>
</li>
<li><strong>On Failure</strong> (<code>RegexError</code>):
<ul>
<li>Indicates why the operation failed (e.g., invalid regex).</li>
</ul>
</li>
</ul>
<hr />
<h3 id="behavior-4"><a class="header" href="#behavior-4"><strong>Behavior</strong></a></h3>
<ol>
<li>
<p><strong>Input Validation</strong>:</p>
<ul>
<li>Checks if the regex has been compiled.</li>
<li>Returns <code>#NotCompiled</code> error if unavailable.</li>
</ul>
</li>
<li>
<p><strong>Splitting Process</strong>:</p>
<ul>
<li>Matches the regex pattern in the input string.</li>
<li>Divides the string at each match, respecting the <code>maxSplit</code> limit if provided.</li>
<li>Handles edge cases (e.g., no matches or empty input).</li>
</ul>
</li>
<li>
<p><strong>Result Construction</strong>:</p>
<ul>
<li>Returns a vector of substrings on success.</li>
<li>Returns <code>RegexError</code> for invalid inputs or uncompiled regex.</li>
</ul>
</li>
</ol>
<hr />
<h3 id="example-usage-4"><a class="header" href="#example-usage-4"><strong>Example Usage</strong></a></h3>
<h4 id="1-splitting-without-limit"><a class="header" href="#1-splitting-without-limit"><strong>1. Splitting Without Limit</strong></a></h4>
<pre><code class="language-motoko">let splitRegex = Regex.Regex(",");
let result = splitRegex.split("one,two,three", null);

switch (result) {
  case (#ok(parts)) {
    Debug.print("Split result: " # debug_show(parts));
  };
  case (#err(error)) {
    Debug.print("Error: " # debug_show(error));
  };
}
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code>Split result: ["one", "two", "three"]
</code></pre>
<hr />
<h4 id="2-splitting-with-limit"><a class="header" href="#2-splitting-with-limit"><strong>2. Splitting With Limit</strong></a></h4>
<pre><code class="language-motoko">let splitRegex = Regex.Regex(",");
let result = splitRegex.split("one,two,three", ?1);

switch (result) {
  case (#ok(parts)) {
    Debug.print("Split result: " # debug_show(parts));
  };
  case (#err(error)) {
    Debug.print("Error: " # debug_show(error));
  };
}
</code></pre>
<p><strong>Output</strong>:</p>
<pre><code>Split result: ["one", "two,three"]
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="inspectregex"><a class="header" href="#inspectregex">inspectRegex()</a></h1>
<p>Returns a detailed text representation of the NFA structure for a compiled regular expression pattern.</p>
<h2 id="overview-5"><a class="header" href="#overview-5">Overview</a></h2>
<p>The <code>inspectRegex()</code> function allows you to examine the internal NFA (Non-deterministic Finite Automaton) structure of a compiled regular expression. This is particularly useful for debugging complex patterns and understanding how the regex engine processes matches.</p>
<h2 id="return-value-7"><a class="header" href="#return-value-7">Return Value</a></h2>
<ul>
<li>Type: <code>Result.Result&lt;Text, RegexError&gt;</code></li>
<li>Success: Returns <code>#ok(Text)</code> with formatted NFA representation</li>
<li>Error: Returns <code>#err(#NotCompiled)</code> if regex is not compiled</li>
</ul>
<h2 id="example-social-security-number-pattern"><a class="header" href="#example-social-security-number-pattern">Example: Social Security Number Pattern</a></h2>
<pre><code class="language-motoko">// Create regex for basic SSN pattern: ^\d{3}-\d{2}-\d{4}$
let regex = Regex.new("^\\d{3}-\\d{2}-\\d{4}$");

// Inspect the NFA structure
switch(regex.inspectRegex()) {
    case (#ok(nfa)) Debug.print(nfa);
    case (#err(e)) Debug.print("Error: Not compiled");
};
</code></pre>
<h3 id="example-output"><a class="header" href="#example-output">Example Output</a></h3>
<pre><code>=== NFA State Machine ===
Initial State → 0
Accept States → [11]

=== Transitions ===
From State 0:
  #Range('0', '9') → 1 (#Greedy)

From State 1:
  #Range('0', '9') → 2 (#Greedy)

From State 2:
  #Range('0', '9') → 3 (#Greedy)

From State 3:
  #Char('-') → 4

From State 4:
  #Range('0', '9') → 5 (#Greedy)

From State 5:
  #Range('0', '9') → 6 (#Greedy)

From State 6:
  #Char('-') → 7

From State 7:
  #Range('0', '9') → 8 (#Greedy)

From State 8:
  #Range('0', '9') → 9 (#Greedy)

From State 9:
  #Range('0', '9') → 10 (#Greedy)

From State 10:
  #Range('0', '9') → 11 (#Greedy)

=== Assertions ===
Anchor: {aType = #StartOfString; position = 0}
Anchor: {aType = #EndOfString; position = 11}
</code></pre>
<h2 id="pattern-breakdown"><a class="header" href="#pattern-breakdown">Pattern Breakdown</a></h2>
<p>The NFA structure represents the SSN pattern <code>^\d{3}-\d{2}-\d{4}$</code> as follows:</p>
<ol>
<li>Start anchor at position 0</li>
<li>States 0-2: First three digits (<code>\d{3}</code>) with greedy quantifiers</li>
<li>State 3: Literal hyphen (<code>-</code>)</li>
<li>States 4-5: Next two digits (<code>\d{2}</code>) with greedy quantifiers</li>
<li>State 6: Second hyphen (<code>-</code>)</li>
<li>States 7-10: Final four digits (<code>\d{4}</code>) with greedy quantifiers</li>
<li>State 11: Accept state</li>
<li>End anchor at position 11</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inspectstatestate-typesstate"><a class="header" href="#inspectstatestate-typesstate">inspectState(state: Types.State)</a></h1>
<p>Examines and returns the transitions for a specific state in the NFA (Non-deterministic Finite Automaton) structure.</p>
<h2 id="overview-6"><a class="header" href="#overview-6">Overview</a></h2>
<p>The <code>inspectState()</code> function allows you to inspect the transitions from any particular state in the compiled regex pattern. This is useful for debugging specific parts of pattern matching behavior.</p>
<h2 id="parameters-7"><a class="header" href="#parameters-7">Parameters</a></h2>
<ul>
<li><code>state</code>: Nat - The state number to inspect</li>
</ul>
<h2 id="return-value-8"><a class="header" href="#return-value-8">Return Value</a></h2>
<ul>
<li>Type: <code>Result.Result&lt;Text, RegexError&gt;</code></li>
<li>Success: Returns <code>#ok(Text)</code> with formatted transitions from the specified state</li>
<li>Error: Returns <code>#err(#NotCompiled)</code> if regex is not compiled</li>
</ul>
<h2 id="example-social-security-number-pattern-state"><a class="header" href="#example-social-security-number-pattern-state">Example: Social Security Number Pattern State</a></h2>
<p>Using the same SSN pattern (<code>^\d{3}-\d{2}-\d{4}$</code>), let's inspect state 4, which handles the first digit after the first hyphen:</p>
<pre><code class="language-motoko">let regex = Regex.Regex("^\d{3}-\d{2}-\d{4}$");

switch(regex.inspectState(3)) {
    case (#ok(transitions)) Debug.print(transitions);
    case (#err(e)) Debug.print("Error: Not compiled");
};
</code></pre>
<h3 id="example-output-1"><a class="header" href="#example-output-1">Example Output</a></h3>
<pre><code>From State 3:
  #Char('-') → 4
</code></pre>
<p>This shows the transitions available for state 3 in the NFA. There is only one transition available for state 3 which is the dash character.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enabledebugb-bool"><a class="header" href="#enabledebugb-bool">enableDebug(b: Bool)</a></h1>
<p>Toggles debug logging for the regex matcher. When enabled, it provides detailed logging of the pattern matching process.</p>
<h2 id="parameters-8"><a class="header" href="#parameters-8">Parameters</a></h2>
<ul>
<li><code>b</code>: Bool - Set to true to enable debug logging, false to disable it</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview-7"><a class="header" href="#overview-7">Overview</a></h1>
<p>The <code>Match</code> record represents the result of a pattern matching operation on text, typically used in regular expression or string matching operations. It contains detailed information about what was matched, where it was found, and any captured groups within the match.</p>
<h2 id="structure"><a class="header" href="#structure">Structure</a></h2>
<pre><code class="language-motoko">public type Match = {
    string: Text;
    value: Text;
    status: {
        #FullMatch;
        #NoMatch;
    };
    position: (Nat, Nat);
    capturedGroups: ?[(Text,Nat)];
    spans: [(Nat, Nat)];
    lastIndex: Nat;
};
</code></pre>
<h2 id="field-descriptions"><a class="header" href="#field-descriptions">Field Descriptions</a></h2>
<h3 id="string-text"><a class="header" href="#string-text">string: Text</a></h3>
<p>The original input string that was searched for matches. This field preserves the complete text that was analyzed during the matching operation.</p>
<h3 id="value-text"><a class="header" href="#value-text">value: Text</a></h3>
<p>The actual matched substring found in the original text. This represents the specific portion of text that satisfied the matching criteria.</p>
<h3 id="status"><a class="header" href="#status">status</a></h3>
<p>An enumerated type that indicates the match result:</p>
<ul>
<li><code>#FullMatch</code>: Indicates a successful match was found</li>
<li><code>#NoMatch</code>: Indicates no match was found in the input string</li>
</ul>
<h3 id="position-nat-nat"><a class="header" href="#position-nat-nat">position: (Nat, Nat)</a></h3>
<p>A tuple containing the start and end indices of the match in the original string:</p>
<ul>
<li>First value: Starting index of the match</li>
<li>Second value: Ending index of the match</li>
</ul>
<h3 id="capturedgroups-textnat"><a class="header" href="#capturedgroups-textnat">capturedGroups: ?[(Text,Nat)]</a></h3>
<p>An optional array of tuples containing captured groups from the match:</p>
<ul>
<li>Each tuple contains:
<ul>
<li>Text: The captured text</li>
<li>Nat: The index of the captured group</li>
</ul>
</li>
<li><code>null</code> if no groups were captured</li>
</ul>
<h3 id="spans-nat-nat"><a class="header" href="#spans-nat-nat">spans: [(Nat, Nat)]</a></h3>
<p>An array of tuples representing the character spans of the respective match</p>
<h3 id="lastindex-nat"><a class="header" href="#lastindex-nat">lastIndex: Nat</a></h3>
<p>The index where the last match ended. This is particularly useful when performing multiple sequential matches on the same text.</p>
<h2 id="usage-examples"><a class="header" href="#usage-examples">Usage Examples</a></h2>
<h3 id="basic-match-checking"><a class="header" href="#basic-match-checking">Basic Match Checking</a></h3>
<pre><code class="language-motoko">if (matchResult.status == #FullMatch) {
    Debug.print("Found match: " # matchResult.value);
} else {
    Debug.print("No match found");
};
</code></pre>
<h3 id="working-with-captured-groups"><a class="header" href="#working-with-captured-groups">Working with Captured Groups</a></h3>
<pre><code class="language-motoko">switch (matchResult.capturedGroups) {
    case (null) { Debug.print("No groups captured") };
    case (?groups) {
        for ((text, index) in groups.vals()) {
            Debug.print("Group " # debug_show(index) # ": " # text);
        };
    };
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unicode-support-and-unicode-properties"><a class="header" href="#unicode-support-and-unicode-properties">Unicode Support and Unicode Properties</a></h1>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>The Motoko Regex Engine supports Unicode properties, allowing users to match specific character categories using <code>\p{Property}</code> and <code>\P{Property}</code> syntax. This enhances pattern matching by enabling character classification based on Unicode properties.</p>
<h2 id="syntax-1"><a class="header" href="#syntax-1">Syntax</a></h2>
<p>Unicode properties can be matched using the following syntax:</p>
<pre><code class="language-regex">\p{Property}   // Matches a character with the specified Unicode property
\P{Property}   // Matches a character that does NOT have the specified Unicode property
</code></pre>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<pre><code class="language-regex">\p{L}   // Matches any letter
\p{N}   // Matches any number
\P{P}   // Matches any character except punctuation
</code></pre>
<h2 id="supported-unicode-properties"><a class="header" href="#supported-unicode-properties">Supported Unicode Properties</a></h2>
<p>The engine supports a subset of Unicode properties:</p>
<ul>
<li><code>L</code>  (Letter)</li>
<li><code>Ll</code> (Lowercase Letter)</li>
<li><code>Lu</code> (Uppercase Letter)</li>
<li><code>N</code>  (Number)</li>
<li><code>P</code>  (Punctuation)</li>
<li><code>Zs</code> (Separator, Space)</li>
<li><code>Emoji</code> (Emoji characters)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="backreferences"><a class="header" href="#backreferences">Backreferences</a></h1>
<h2 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h2>
<p>Backreferences allow a regular expression to match repeated substrings by referring back to a previously captured group. They enable patterns to enforce consistency within the matched text.</p>
<h2 id="syntax-2"><a class="header" href="#syntax-2">Syntax</a></h2>
<p>Backreferences use the following syntax:</p>
<ul>
<li><code>\1, \2, ...</code>: Refers to a numbered capturing group in order of appearance and can only be used in <code>replace</code> and <code>sub</code> methods.</li>
<li><code>\k&lt;name&gt;</code>: Refers to a named capturing group and can be used within matching.</li>
</ul>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<pre><code class="language-regex">(?&lt;greeting&gt;hello)\s+\k&lt;greeting&gt;
</code></pre>
<p>This matches hello followed by one or more space followed by hello again.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lookaround-assertions"><a class="header" href="#lookaround-assertions">Lookaround Assertions</a></h1>
<h2 id="introduction-3"><a class="header" href="#introduction-3">Introduction</a></h2>
<p>Lookaround assertions allow for pattern matching based on surrounding text without including that text in the final match. They enable advanced pattern constraints while maintaining flexibility in regex processing. However, in many cases, using a stricter pattern without lookarounds can be a better approach, leading to simpler and more efficient regex expressions.</p>
<h2 id="lookaround-types"><a class="header" href="#lookaround-types">Lookaround Types</a></h2>
<p>Lookaround assertions are divided into <strong>Lookahead</strong> and <strong>Lookbehind</strong>, and each has <strong>Positive</strong> and <strong>Negative</strong> variations. The following table summarizes them:</p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Positive</th><th>Negative</th></tr></thead><tbody>
<tr><td><strong>Look-Ahead</strong></td><td><code>A(?=B)</code> - Match <code>A</code> if <code>B</code> follows</td><td><code>A(?!B)</code> - Match <code>A</code> if <code>B</code> does <strong>not</strong> follow</td></tr>
<tr><td><strong>Look-Behind</strong></td><td><code>(?&lt;=B)A</code> - Match <code>A</code> if <code>B</code> precedes</td><td><code>(?&lt;!B)A</code> - Match <code>A</code> if <code>B</code> does <strong>not</strong> precede</td></tr>
</tbody></table>
</div>
<h3 id="lookahead"><a class="header" href="#lookahead">Lookahead</a></h3>
<ul>
<li><strong>Positive Lookahead (<code>?=</code>)</strong>: Ensures a pattern exists after the current position without consuming it.</li>
<li><strong>Negative Lookahead (<code>?!</code>)</strong>: Ensures a pattern does <em>not</em> exist after the current position.</li>
</ul>
<pre><code class="language-regex">foo(?=bar)   // Matches "foo" only if followed by "bar"
foo(?!bar)   // Matches "foo" only if NOT followed by "bar"
</code></pre>
<h3 id="lookbehind"><a class="header" href="#lookbehind">Lookbehind</a></h3>
<ul>
<li><strong>Positive Lookbehind (<code>?&lt;=</code>)</strong>: Ensures a pattern exists before the current position.</li>
<li><strong>Negative Lookbehind (<code>?&lt;!</code>)</strong>: Ensures a pattern does <em>not</em> exist before the current position.</li>
</ul>
<pre><code class="language-regex">(?&lt;=bar)foo   // Matches "foo" only if preceded by "bar"
(?&lt;!bar)foo   // Matches "foo" only if NOT preceded by "bar"
</code></pre>
<h2 id="behavior-and-considerations"><a class="header" href="#behavior-and-considerations">Behavior and Considerations</a></h2>
<ul>
<li>Lookaround assertions do not consume characters; they only assert conditions.</li>
<li>Combining lookahead and lookbehind can create complex matching rules.</li>
<li>Negative lookaround can be used to enforce exclusions in matching.</li>
<li>Lookbehind patterns must have a fixed length.</li>
<li>In many cases, defining a stricter pattern instead of relying on lookaround assertions results in a more efficient and readable regex.</li>
</ul>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Lookaround assertions provide powerful matching capabilities without consuming characters. However, in most cases, defining a stricter pattern can lead to better performance and clarity. The Motoko Regex Engine supports both lookahead and lookbehind assertions, but users should consider whether they can achieve the same result with a more precise pattern before resorting to lookarounds.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="regex-examples-for-motoko-regex-engine"><a class="header" href="#regex-examples-for-motoko-regex-engine">Regex Examples for Motoko Regex Engine</a></h1>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="examples.html#regex-examples-for-motoko-regex-engine">Regex Examples for Motoko Regex Engine</a>
<ul>
<li><a href="examples.html#table-of-contents">Table of Contents</a></li>
<li><a href="examples.html#internet-computer-identifiers">Internet Computer Identifiers</a>
<ul>
<li><a href="examples.html#principal-id">Principal ID</a></li>
<li><a href="examples.html#account-id">Account ID</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="internet-computer-identifiers"><a class="header" href="#internet-computer-identifiers">Internet Computer Identifiers</a></h2>
<h3 id="principal-id"><a class="header" href="#principal-id">Principal ID</a></h3>
<p>Pattern to validate Principal ID format.</p>
<pre><code class="language-motoko">// Anonymous Principal will be rejected
let principalPattern = Regex.Regex("^[a-z0-9]{5}-[a-z0-9]{5}-[a-z0-9]{5}-[a-z0-9]{5}-[a-z0-9]{3}$", null);
public func validatePrincipalId(id: Text): Bool {
    switch(principalPattern.match(id)) {
        case (#ok(result)) {
            switch(result.status) {
                case (#FullMatch) true;
                case (#NoMatch) false;
            };
        };
        case (#err(_)) false;
    };
};
</code></pre>
<h3 id="account-id"><a class="header" href="#account-id">Account ID</a></h3>
<p>Pattern to validate Account ID format.</p>
<pre><code class="language-motoko">// Account ID (32 bytes in hexadecimal)
let accountPattern = Regex.Regex("^[0-9a-f]{64}$", null);
public func validateAccountId(id: Text): Bool {
    switch(accountPattern.match(id)) {
        case (#ok(result)) {
            switch(result.status) {
                case (#FullMatch) true;
                case (#NoMatch) false;
            };
        };
        case (#err(_)) false;
    };
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-to-motoko-regex-engine"><a class="header" href="#contributing-to-motoko-regex-engine">Contributing to Motoko Regex Engine</a></h1>
<p>Thank you for your interest in contributing to the Motoko Regex Engine project! This guide will help you get started with contributing to the project.</p>
<h2 id="table-of-contents-1"><a class="header" href="#table-of-contents-1">Table of Contents</a></h2>
<ul>
<li><a href="contributing.html#contributing-to-motoko-regex-engine">Contributing to Motoko Regex Engine</a>
<ul>
<li><a href="contributing.html#table-of-contents">Table of Contents</a></li>
<li><a href="contributing.html#getting-started">Getting Started</a></li>
<li><a href="contributing.html#development-process">Development Process</a></li>
<li><a href="contributing.html#commit-guidelines">Commit Guidelines</a></li>
<li><a href="contributing.html#pull-request-process">Pull Request Process</a></li>
<li><a href="contributing.html#testing-requirements">Testing Requirements</a></li>
</ul>
</li>
</ul>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<ol>
<li>
<p>Fork the repository:</p>
<ul>
<li>Visit <a href="https://github.com/Demali-876/motoko_regex_engine">https://github.com/Demali-876/motoko_regex_engine</a></li>
<li>Click the "Fork" button in the top-right corner</li>
</ul>
</li>
<li>
<p>Clone your fork:</p>
<pre><code class="language-bash">git clone https://github.com/YOUR-USERNAME/motoko_regex_engine.git
cd motoko_regex_engine
</code></pre>
</li>
<li>
<p>Add the upstream repository:</p>
<pre><code class="language-bash">git remote add upstream https://github.com/Demali-876/motoko_regex_engine.git
</code></pre>
</li>
<li>
<p>Create a new branch for your work:</p>
<pre><code class="language-bash">git checkout -b feat/your-feature-name
</code></pre>
</li>
</ol>
<h2 id="development-process"><a class="header" href="#development-process">Development Process</a></h2>
<ol>
<li>
<p>Set up your development environment:</p>
<ul>
<li>Install the DFINITY SDK (dfx)</li>
<li>Install Node.js and npm</li>
<li>Run <code>npm install</code> to install dependencies</li>
</ul>
</li>
<li>
<p>Make your changes:</p>
<ul>
<li>Keep your changes focused and concise</li>
<li>Update documentation if needed</li>
</ul>
</li>
<li>
<p>Keep your fork up to date:</p>
<pre><code class="language-bash">git fetch upstream
git rebase upstream/main
</code></pre>
</li>
</ol>
<h2 id="commit-guidelines"><a class="header" href="#commit-guidelines">Commit Guidelines</a></h2>
<p>We use <a href="https://www.conventionalcommits.org/">Conventional Commits</a> for clear and standardized commit messages. Each commit message should be structured as follows:</p>
<pre><code>&lt;type&gt;[optional scope]: &lt;description&gt;

[optional body]

[optional footer(s)]
</code></pre>
<p>Types:</p>
<ul>
<li><code>feat</code>: A new feature</li>
<li><code>fix</code>: A bug fix</li>
<li><code>docs</code>: Documentation only changes</li>
<li><code>style</code>: Changes that do not affect the meaning of the code</li>
<li><code>refactor</code>: A code change that neither fixes a bug nor adds a feature</li>
<li><code>perf</code>: A code change that improves performance</li>
<li><code>test</code>: Adding missing tests or correcting existing tests</li>
<li><code>chore</code>: Changes to the build process or auxiliary tools</li>
</ul>
<p>Examples:</p>
<pre><code>feat(parser): add support for lookahead assertions

fix(matcher): resolve infinite loop in nested groups

docs: update API documentation for search method

refactor(compiler): simplify NFA construction logic
</code></pre>
<h2 id="pull-request-process"><a class="header" href="#pull-request-process">Pull Request Process</a></h2>
<ol>
<li>
<p>Push your changes to your fork:</p>
<pre><code class="language-bash">git push origin feat/your-feature-name
</code></pre>
</li>
<li>
<p>Create a Pull Request:</p>
<ul>
<li>Go to <a href="https://github.com/Demali-876/motoko_regex_engine/pulls">https://github.com/Demali-876/motoko_regex_engine/pulls</a></li>
<li>Click "New Pull Request"</li>
<li>Select your fork and branch</li>
<li>Fill out the PR template with:
<ul>
<li>Clear description of changes</li>
<li>Any breaking changes</li>
<li>Evidence of testing (screenshots, console output, etc.)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>PR Review Process:</p>
<ul>
<li>Maintainers will review your PR</li>
<li>Address any requested changes</li>
<li>Once approved, your PR will be merged</li>
</ul>
</li>
</ol>
<h2 id="testing-requirements"><a class="header" href="#testing-requirements">Testing Requirements</a></h2>
<p>While formal tests are not required, you must provide evidence that you've tested your changes. This can include:</p>
<ul>
<li>Screenshots of the feature working</li>
<li>Console output showing successful execution</li>
<li>Example usage and results</li>
<li>Description of test cases you've tried</li>
</ul>
<p>Example test evidence in PR:</p>
<pre><code>Tested the new alternation operator with:
1. Simple patterns: "a|b" against "a" and "b"
2. Complex patterns: "(foo|bar)+" against "foofoobar"
3. Edge cases: "a||b" and "|a|b|"

Results:
- All patterns matched correctly
- No infinite loops or crashes
- Proper error handling for invalid patterns
</code></pre>
<p>Thank you for contributing to the Motoko Regex Engine project!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
